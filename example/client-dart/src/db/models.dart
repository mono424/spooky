// This file is auto-generated. Do not edit manually.
// Generated by syncgen - any changes will be overwritten.

// To parse this JSON data, do
//
//     final schema = schemaFromJson(jsonString);

import 'dart:convert';

Schema schemaFromJson(String str) => Schema.fromJson(json.decode(str));

String schemaToJson(Schema data) => json.encode(data.toJson());

class Schema {
    Comment comment;
    CommentedOn commentedOn;
    SpookyDataHash spookyDataHash;
    SpookyIncantation spookyIncantation;
    SpookyIncantationLookup spookyIncantationLookup;
    SpookyIncantationTail spookyIncantationTail;
    SpookyRelationship spookyRelationship;
    Thread thread;
    User user;

    Schema({
        required this.comment,
        required this.commentedOn,
        required this.spookyDataHash,
        required this.spookyIncantation,
        required this.spookyIncantationLookup,
        required this.spookyIncantationTail,
        required this.spookyRelationship,
        required this.thread,
        required this.user,
    });

    factory Schema.fromJson(Map<String, dynamic> json) => Schema(
        comment: Comment.fromJson(json["comment"]),
        commentedOn: CommentedOn.fromJson(json["commented_on"]),
        spookyDataHash: SpookyDataHash.fromJson(json["spooky_data_hash"]),
        spookyIncantation: SpookyIncantation.fromJson(json["spooky_incantation"]),
        spookyIncantationLookup: SpookyIncantationLookup.fromJson(json["spooky_incantation_lookup"]),
        spookyIncantationTail: SpookyIncantationTail.fromJson(json["spooky_incantation_tail"]),
        spookyRelationship: SpookyRelationship.fromJson(json["spooky_relationship"]),
        thread: Thread.fromJson(json["thread"]),
        user: User.fromJson(json["user"]),
    );

    Map<String, dynamic> toJson() => {
        "comment": comment.toJson(),
        "commented_on": commentedOn.toJson(),
        "spooky_data_hash": spookyDataHash.toJson(),
        "spooky_incantation": spookyIncantation.toJson(),
        "spooky_incantation_lookup": spookyIncantationLookup.toJson(),
        "spooky_incantation_tail": spookyIncantationTail.toJson(),
        "spooky_relationship": spookyRelationship.toJson(),
        "thread": thread.toJson(),
        "user": user.toJson(),
    };
}

class Comment {
    
    ///Record ID of table: user
    String author;
    
    ///Assert: $value != NONE AND string::len($value) > 0
    String content;
    DateTime? createdAt;
    
    ///Record ID
    String id;
    
    ///Record ID of table: thread
    String thread;

    Comment({
        required this.author,
        required this.content,
        this.createdAt,
        required this.id,
        required this.thread,
    });

    factory Comment.fromJson(Map<String, dynamic> json) => Comment(
        author: json["author"],
        content: json["content"],
        createdAt: json["created_at"] == null ? null : DateTime.parse(json["created_at"]),
        id: json["id"],
        thread: json["thread"],
    );

    Map<String, dynamic> toJson() => {
        "author": author,
        "content": content,
        "created_at": createdAt?.toIso8601String(),
        "id": id,
        "thread": thread,
    };
}

class CommentedOn {
    
    ///Record ID
    String id;

    CommentedOn({
        required this.id,
    });

    factory CommentedOn.fromJson(Map<String, dynamic> json) => CommentedOn(
        id: json["id"],
    );

    Map<String, dynamic> toJson() => {
        "id": id,
    };
}

class SpookyDataHash {
    
    ///Any type
    dynamic compositionHash;
    
    ///Record ID
    String id;
    
    ///Any type
    dynamic intrinsicHash;
    
    ///Record ID
    String recordId;
    
    ///Any type
    dynamic totalHash;

    SpookyDataHash({
        required this.compositionHash,
        required this.id,
        required this.intrinsicHash,
        required this.recordId,
        required this.totalHash,
    });

    factory SpookyDataHash.fromJson(Map<String, dynamic> json) => SpookyDataHash(
        compositionHash: json["CompositionHash"],
        id: json["id"],
        intrinsicHash: json["IntrinsicHash"],
        recordId: json["RecordId"],
        totalHash: json["TotalHash"],
    );

    Map<String, dynamic> toJson() => {
        "CompositionHash": compositionHash,
        "id": id,
        "IntrinsicHash": intrinsicHash,
        "RecordId": recordId,
        "TotalHash": totalHash,
    };
}

class SpookyIncantation {
    
    ///Any type
    dynamic hash;
    
    ///Record ID
    String spookyIncantationId;
    String id;
    DateTime lastActiveAt;
    String surrealQl;
    
    ///ISO 8601 duration
    String ttl;

    SpookyIncantation({
        required this.hash,
        required this.spookyIncantationId,
        required this.id,
        required this.lastActiveAt,
        required this.surrealQl,
        required this.ttl,
    });

    factory SpookyIncantation.fromJson(Map<String, dynamic> json) => SpookyIncantation(
        hash: json["Hash"],
        spookyIncantationId: json["id"],
        id: json["Id"],
        lastActiveAt: DateTime.parse(json["LastActiveAt"]),
        surrealQl: json["SurrealQL"],
        ttl: json["TTL"],
    );

    Map<String, dynamic> toJson() => {
        "Hash": hash,
        "id": spookyIncantationId,
        "Id": id,
        "LastActiveAt": lastActiveAt.toIso8601String(),
        "SurrealQL": surrealQl,
        "TTL": ttl,
    };
}

class SpookyIncantationLookup {
    String table;
    
    ///Any type
    dynamic where;
    
    ///Record ID
    String id;
    String incantationId;
    List<String> sortDirections;
    List<String> sortFields;

    SpookyIncantationLookup({
        required this.table,
        required this.where,
        required this.id,
        required this.incantationId,
        required this.sortDirections,
        required this.sortFields,
    });

    factory SpookyIncantationLookup.fromJson(Map<String, dynamic> json) => SpookyIncantationLookup(
        table: json["`Table`"],
        where: json["`Where`"],
        id: json["id"],
        incantationId: json["IncantationId"],
        sortDirections: List<String>.from(json["SortDirections"].map((x) => x)),
        sortFields: List<String>.from(json["SortFields"].map((x) => x)),
    );

    Map<String, dynamic> toJson() => {
        "`Table`": table,
        "`Where`": where,
        "id": id,
        "IncantationId": incantationId,
        "SortDirections": List<dynamic>.from(sortDirections.map((x) => x)),
        "SortFields": List<dynamic>.from(sortFields.map((x) => x)),
    };
}

class SpookyIncantationTail {
    
    ///Record ID
    String id;
    String incantationId;
    List<dynamic> tailValues;

    SpookyIncantationTail({
        required this.id,
        required this.incantationId,
        required this.tailValues,
    });

    factory SpookyIncantationTail.fromJson(Map<String, dynamic> json) => SpookyIncantationTail(
        id: json["id"],
        incantationId: json["IncantationId"],
        tailValues: List<dynamic>.from(json["TailValues"].map((x) => x)),
    );

    Map<String, dynamic> toJson() => {
        "id": id,
        "IncantationId": incantationId,
        "TailValues": List<dynamic>.from(tailValues.map((x) => x)),
    };
}

class SpookyRelationship {
    String childField;
    String childTable;
    
    ///Record ID
    String id;
    String parentTable;
    
    ///Assert: $value INSIDE ['COMPOSITION', 'REFERENCE']
    String type;

    SpookyRelationship({
        required this.childField,
        required this.childTable,
        required this.id,
        required this.parentTable,
        required this.type,
    });

    factory SpookyRelationship.fromJson(Map<String, dynamic> json) => SpookyRelationship(
        childField: json["ChildField"],
        childTable: json["ChildTable"],
        id: json["id"],
        parentTable: json["ParentTable"],
        type: json["Type"],
    );

    Map<String, dynamic> toJson() => {
        "ChildField": childField,
        "ChildTable": childTable,
        "id": id,
        "ParentTable": parentTable,
        "Type": type,
    };
}

class Thread {
    
    ///Record ID of table: user
    String author;
    
    ///Reverse relationship: array of comment records
    List<String>? comments;
    
    ///Assert: $value != NONE AND string::len($value) > 0
    String content;
    DateTime? createdAt;
    
    ///Record ID
    String id;
    
    ///Assert: $value != NONE AND string::len($value) > 0 AND string::len($value) <= 200
    String title;

    Thread({
        required this.author,
        this.comments,
        required this.content,
        this.createdAt,
        required this.id,
        required this.title,
    });

    factory Thread.fromJson(Map<String, dynamic> json) => Thread(
        author: json["author"],
        comments: json["comments"] == null ? [] : List<String>.from(json["comments"]!.map((x) => x)),
        content: json["content"],
        createdAt: json["created_at"] == null ? null : DateTime.parse(json["created_at"]),
        id: json["id"],
        title: json["title"],
    );

    Map<String, dynamic> toJson() => {
        "author": author,
        "comments": comments == null ? [] : List<dynamic>.from(comments!.map((x) => x)),
        "content": content,
        "created_at": createdAt?.toIso8601String(),
        "id": id,
        "title": title,
    };
}

class User {
    
    ///Reverse relationship: array of comment records
    List<String>? comments;
    
    ///Record ID
    String id;
    
    ///Reverse relationship: array of thread records
    List<String>? threads;
    
    ///Assert: $value != NONE AND string::is::alphanum($value) AND string::len($value) > 3
    String username;

    User({
        this.comments,
        required this.id,
        this.threads,
        required this.username,
    });

    factory User.fromJson(Map<String, dynamic> json) => User(
        comments: json["comments"] == null ? [] : List<String>.from(json["comments"]!.map((x) => x)),
        id: json["id"],
        threads: json["threads"] == null ? [] : List<String>.from(json["threads"]!.map((x) => x)),
        username: json["username"],
    );

    Map<String, dynamic> toJson() => {
        "comments": comments == null ? [] : List<dynamic>.from(comments!.map((x) => x)),
        "id": id,
        "threads": threads == null ? [] : List<dynamic>.from(threads!.map((x) => x)),
        "username": username,
    };
}


/// The complete SurrealDB schema definition.
/// This constant contains the raw .surql schema file content.
const String SURQL_SCHEMA = "-- ##################################################################
-- SCOPES & AUTHENTICATION
-- ##################################################################
DEFINE ACCESS account ON DATABASE TYPE RECORD
	SIGNUP ( CREATE user SET username = \$username, password = crypto::argon2::generate(\$password) )
	SIGNIN ( SELECT * FROM user WHERE username = \$username AND crypto::argon2::compare(password, \$password) )
	DURATION FOR TOKEN 365d, FOR SESSION 365d
;

-- ##################################################################
-- USER TABLE
-- ##################################################################

DEFINE TABLE user SCHEMAFULL
PERMISSIONS
  FOR update, delete, create WHERE \$access = \"account\" AND id = \$auth.id
  FOR select WHERE true;

DEFINE FIELD username ON TABLE user TYPE string
ASSERT \$value != NONE AND string::is::alphanum(\$value) AND string::len(\$value) > 3
PERMISSIONS
    FOR select WHERE true
    FOR update WHERE \$access = \"account\" AND id = \$auth.id;
    
DEFINE INDEX unique_username ON TABLE user FIELDS username UNIQUE;



-- ##################################################################
-- THREAD TABLE
-- ##################################################################

DEFINE TABLE thread SCHEMAFULL
  PERMISSIONS
    FOR select WHERE true
    FOR update, delete, create WHERE \$access = \"account\" AND author.id = \$auth.id
;


DEFINE FIELD title ON TABLE thread TYPE string
    ASSERT \$value != NONE AND string::len(\$value) > 0 AND string::len(\$value) <= 200;

DEFINE FIELD content ON TABLE thread TYPE string
    ASSERT \$value != NONE AND string::len(\$value) > 0;

DEFINE FIELD author ON TABLE thread TYPE record<user>;

DEFINE FIELD created_at ON TABLE thread TYPE datetime
    VALUE time::now();

-- ##################################################################
-- COMMENT TABLE
-- ##################################################################

DEFINE TABLE comment SCHEMAFULL
  PERMISSIONS
    FOR select WHERE true
    FOR update, delete, create WHERE \$access = \"account\" AND author.id = \$auth.id
;

DEFINE FIELD thread ON TABLE comment TYPE record<thread>; -- @parent

DEFINE FIELD content ON TABLE comment TYPE string
    ASSERT \$value != NONE AND string::len(\$value) > 0;

DEFINE FIELD author ON TABLE comment TYPE record<user>;

DEFINE FIELD created_at ON TABLE comment TYPE datetime
    VALUE time::now();

-- ##################################################################
-- RELATION TABLES
-- ##################################################################

DEFINE TABLE commented_on SCHEMAFULL TYPE RELATION
  FROM comment TO thread
  PERMISSIONS FOR select WHERE true;

DEFINE EVENT comment_created ON TABLE comment WHEN \$event = \"CREATE\" THEN
  RELATE (\$after.id)->commented_on->(\$after.thread)
;

-- ==================================================
-- 1. SPOOKY DATA HASH
-- The \"Shadow Graph\" tracking the state of every record.
-- ==================================================

DEFINE TABLE spooky_data_hash SCHEMAFULL
    PERMISSIONS FULL; -- In prod, you might restrict write access to server-side only

-- The actual record being tracked (e.g., comment:abc, thread:123)
DEFINE FIELD RecordId ON TABLE spooky_data_hash TYPE record;

-- H_intrinsic: BLAKE3 hash of the record's own scalar fields
DEFINE FIELD IntrinsicHash ON TABLE spooky_data_hash TYPE bytes;

-- H_composition: XOR sum of all dependent children's TotalHashes
DEFINE FIELD CompositionHash ON TABLE spooky_data_hash TYPE bytes;

-- H_total: Intrinsic XOR Composition
DEFINE FIELD TotalHash ON TABLE spooky_data_hash TYPE bytes;

-- Fast lookup by the original record ID
DEFINE INDEX idx_record_id ON TABLE spooky_data_hash COLUMNS RecordId UNIQUE;


-- ==================================================
-- 2. SPOOKY INCANTATION
-- The Registry of active Live Queries (Incantations).
-- ==================================================

DEFINE TABLE spooky_incantation SCHEMAFULL
    PERMISSIONS FULL;

-- The unique hash ID of the query + params
DEFINE FIELD Id ON TABLE spooky_incantation TYPE string;

-- The raw query string (for re-hydration/debugging)
DEFINE FIELD SurrealQL ON TABLE spooky_incantation TYPE string;

-- The current XOR sum of all results in this query
DEFINE FIELD Hash ON TABLE spooky_incantation TYPE bytes;

-- For garbage collection (Heartbeat)
DEFINE FIELD LastActiveAt ON TABLE spooky_incantation TYPE datetime DEFAULT time::now();

-- How long this Incantation stays alive without activity
DEFINE FIELD TTL ON TABLE spooky_incantation TYPE duration;

-- Cleanup Triggers
-- When an incantation dies, clean up its lookup and tail records
DEFINE EVENT cascade_delete_lookup ON TABLE spooky_incantation WHEN \$event = \"DELETE\" THEN {
    DELETE spooky_incantation_lookup WHERE IncantationId = \$before.Id;
    DELETE spooky_incantation_tail WHERE IncantationId = \$before.Id;
};


-- ==================================================
-- 3. SPOOKY INCANTATION LOOKUP
-- The Reverse Index: Maps Tables -> Incantations
-- ==================================================

DEFINE TABLE spooky_incantation_lookup SCHEMAFULL
    PERMISSIONS FULL;

-- Link to the parent Incantation
DEFINE FIELD IncantationId ON TABLE spooky_incantation_lookup TYPE string;

-- The primary table being queried (e.g., 'thread')
DEFINE FIELD Table ON TABLE spooky_incantation_lookup TYPE string;

-- Filter logic used to check if a dirty record matches this query
-- Stored as an object e.g., { clause: \"importance >= 3\", args: [...] }
DEFINE FIELD Where ON TABLE spooky_incantation_lookup TYPE object;

-- Sorting Metadata needed to maintain order
DEFINE FIELD SortFields ON TABLE spooky_incantation_lookup TYPE array<string>;
DEFINE FIELD SortDirections ON TABLE spooky_incantation_lookup TYPE array<string>; -- 'ASC', 'DESC'

-- Indexes for performance
DEFINE INDEX idx_incantation ON TABLE spooky_incantation_lookup COLUMNS IncantationId;
DEFINE INDEX idx_table ON TABLE spooky_incantation_lookup COLUMNS Table;


-- ==================================================
-- 4. SPOOKY INCANTATION TAIL
-- Cursor Management for Pagination/Limits
-- ==================================================

DEFINE TABLE spooky_incantation_tail SCHEMAFULL
    PERMISSIONS FULL;

-- Link to the parent Incantation
DEFINE FIELD IncantationId ON TABLE spooky_incantation_tail TYPE string;

-- The sort values of the *last* item in the current result set
-- Used to determine if a new record falls inside or outside the LIMIT window.
DEFINE FIELD TailValues ON TABLE spooky_incantation_tail TYPE array<any>;

DEFINE INDEX idx_incantation ON TABLE spooky_incantation_tail COLUMNS IncantationId UNIQUE;


-- ==================================================
-- 5. SPOOKY RELATIONSHIP
-- The Graph Schema: Defines 'Bubble Up' vs 'Cascade Down'
-- ==================================================

DEFINE TABLE spooky_relationship SCHEMAFULL
    PERMISSIONS FULL;

DEFINE FIELD ParentTable ON TABLE spooky_relationship TYPE string;
DEFINE FIELD ChildTable ON TABLE spooky_relationship TYPE string;

-- The field on the Child that holds the Parent's ID
DEFINE FIELD ChildField ON TABLE spooky_relationship TYPE string;

-- The Logic Flow: 'COMPOSITION' (Bubble Up) or 'REFERENCE' (Cascade Down)
DEFINE FIELD Type ON TABLE spooky_relationship TYPE string 
    ASSERT \$value INSIDE ['COMPOSITION', 'REFERENCE'];

-- Enforce unique definition per relationship path
DEFINE INDEX idx_rel_unique ON TABLE spooky_relationship COLUMNS ParentTable, ChildTable, ChildField UNIQUE;";
