// This file is auto-generated. Do not edit manually.
// Generated by syncgen - any changes will be overwritten.

// To parse this JSON data, do
//
//     final schema = schemaFromJson(jsonString);

import 'dart:convert';

Schema schemaFromJson(String str) => Schema.fromJson(json.decode(str));

String schemaToJson(Schema data) => json.encode(data.toJson());

class Schema {
    SpookyIncantation spookyIncantation;
    SpookyPendingMutations spookyPendingMutations;
    SpookySchema spookySchema;
    SpookyStreamProcessorState spookyStreamProcessorState;
    Comment comment;
    CommentedOn commentedOn;
    Thread thread;
    User user;

    Schema({
        required this.spookyIncantation,
        required this.spookyPendingMutations,
        required this.spookySchema,
        required this.spookyStreamProcessorState,
        required this.comment,
        required this.commentedOn,
        required this.thread,
        required this.user,
    });

    factory Schema.fromJson(Map<String, dynamic> json) => Schema(
        spookyIncantation: SpookyIncantation.fromJson(json["_spooky_incantation"]),
        spookyPendingMutations: SpookyPendingMutations.fromJson(json["_spooky_pending_mutations"]),
        spookySchema: SpookySchema.fromJson(json["_spooky_schema"]),
        spookyStreamProcessorState: SpookyStreamProcessorState.fromJson(json["_spooky_stream_processor_state"]),
        comment: Comment.fromJson(json["comment"]),
        commentedOn: CommentedOn.fromJson(json["commented_on"]),
        thread: Thread.fromJson(json["thread"]),
        user: User.fromJson(json["user"]),
    );

    Map<String, dynamic> toJson() => {
        "_spooky_incantation": spookyIncantation.toJson(),
        "_spooky_pending_mutations": spookyPendingMutations.toJson(),
        "_spooky_schema": spookySchema.toJson(),
        "_spooky_stream_processor_state": spookyStreamProcessorState.toJson(),
        "comment": comment.toJson(),
        "commented_on": commentedOn.toJson(),
        "thread": thread.toJson(),
        "user": user.toJson(),
    };
}

class Comment {
    
    ///Record ID of table: user
    String author;
    
    ///Assert: $value != NONE AND string::len($value) > 0
    String content;
    DateTime? createdAt;
    
    ///Record ID
    String id;
    
    ///Record ID of table: thread
    String thread;

    Comment({
        required this.author,
        required this.content,
        this.createdAt,
        required this.id,
        required this.thread,
    });

    factory Comment.fromJson(Map<String, dynamic> json) => Comment(
        author: json["author"],
        content: json["content"],
        createdAt: json["created_at"] == null ? null : DateTime.parse(json["created_at"]),
        id: json["id"],
        thread: json["thread"],
    );

    Map<String, dynamic> toJson() => {
        "author": author,
        "content": content,
        "created_at": createdAt?.toIso8601String(),
        "id": id,
        "thread": thread,
    };
}

class CommentedOn {
    
    ///Record ID
    String id;

    CommentedOn({
        required this.id,
    });

    factory CommentedOn.fromJson(Map<String, dynamic> json) => CommentedOn(
        id: json["id"],
    );

    Map<String, dynamic> toJson() => {
        "id": id,
    };
}

class SpookyIncantation {
    String? clientId;
    String? hash;
    
    ///Record ID
    String id;
    DateTime lastActiveAt;
    String? surrealQl;
    
    ///Any type
    dynamic tree;
    
    ///ISO 8601 duration
    String ttl;

    SpookyIncantation({
        this.clientId,
        this.hash,
        required this.id,
        required this.lastActiveAt,
        this.surrealQl,
        required this.tree,
        required this.ttl,
    });

    factory SpookyIncantation.fromJson(Map<String, dynamic> json) => SpookyIncantation(
        clientId: json["clientId"],
        hash: json["hash"],
        id: json["id"],
        lastActiveAt: DateTime.parse(json["lastActiveAt"]),
        surrealQl: json["surrealQL"],
        tree: json["tree"],
        ttl: json["ttl"],
    );

    Map<String, dynamic> toJson() => {
        "clientId": clientId,
        "hash": hash,
        "id": id,
        "lastActiveAt": lastActiveAt.toIso8601String(),
        "surrealQL": surrealQl,
        "tree": tree,
        "ttl": ttl,
    };
}

class SpookyPendingMutations {
    
    ///Any type
    String? data;
    String id;
    String mutationType;
    
    ///Record ID
    String? recordId;

    SpookyPendingMutations({
        this.data,
        required this.id,
        required this.mutationType,
        this.recordId,
    });

    factory SpookyPendingMutations.fromJson(Map<String, dynamic> json) => SpookyPendingMutations(
        data: json["data"],
        id: json["id"],
        mutationType: json["mutationType"],
        recordId: json["recordId"],
    );

    Map<String, dynamic> toJson() => {
        "data": data,
        "id": id,
        "mutationType": mutationType,
        "recordId": recordId,
    };
}

class SpookySchema {
    DateTime? createdAt;
    String hash;
    String id;

    SpookySchema({
        this.createdAt,
        required this.hash,
        required this.id,
    });

    factory SpookySchema.fromJson(Map<String, dynamic> json) => SpookySchema(
        createdAt: json["created_at"] == null ? null : DateTime.parse(json["created_at"]),
        hash: json["hash"],
        id: json["id"],
    );

    Map<String, dynamic> toJson() => {
        "created_at": createdAt?.toIso8601String(),
        "hash": hash,
        "id": id,
    };
}

class SpookyStreamProcessorState {
    String id;
    String state;
    DateTime? updatedAt;

    SpookyStreamProcessorState({
        required this.id,
        required this.state,
        this.updatedAt,
    });

    factory SpookyStreamProcessorState.fromJson(Map<String, dynamic> json) => SpookyStreamProcessorState(
        id: json["id"],
        state: json["state"],
        updatedAt: json["updated_at"] == null ? null : DateTime.parse(json["updated_at"]),
    );

    Map<String, dynamic> toJson() => {
        "id": id,
        "state": state,
        "updated_at": updatedAt?.toIso8601String(),
    };
}

class Thread {
    bool? active;
    
    ///Record ID of table: user
    String author;
    
    ///Reverse relationship: array of comment records
    List<String>? comments;
    
    ///Assert: $value != NONE AND string::len($value) > 0
    String content;
    DateTime? createdAt;
    
    ///Record ID
    String id;
    
    ///Assert: $value != NONE AND string::len($value) > 0 AND string::len($value) <= 200
    String title;

    Thread({
        this.active,
        required this.author,
        this.comments,
        required this.content,
        this.createdAt,
        required this.id,
        required this.title,
    });

    factory Thread.fromJson(Map<String, dynamic> json) => Thread(
        active: json["active"],
        author: json["author"],
        comments: json["comments"] == null ? [] : List<String>.from(json["comments"]!.map((x) => x)),
        content: json["content"],
        createdAt: json["created_at"] == null ? null : DateTime.parse(json["created_at"]),
        id: json["id"],
        title: json["title"],
    );

    Map<String, dynamic> toJson() => {
        "active": active,
        "author": author,
        "comments": comments == null ? [] : List<dynamic>.from(comments!.map((x) => x)),
        "content": content,
        "created_at": createdAt?.toIso8601String(),
        "id": id,
        "title": title,
    };
}

class User {
    
    ///Reverse relationship: array of comment records
    List<String>? comments;
    
    ///Record ID
    String id;
    
    ///Reverse relationship: array of thread records
    List<String>? threads;
    
    ///Assert: $value != NONE AND string::len($value) > 3
    String username;

    User({
        this.comments,
        required this.id,
        this.threads,
        required this.username,
    });

    factory User.fromJson(Map<String, dynamic> json) => User(
        comments: json["comments"] == null ? [] : List<String>.from(json["comments"]!.map((x) => x)),
        id: json["id"],
        threads: json["threads"] == null ? [] : List<String>.from(json["threads"]!.map((x) => x)),
        username: json["username"],
    );

    Map<String, dynamic> toJson() => {
        "comments": comments == null ? [] : List<dynamic>.from(comments!.map((x) => x)),
        "id": id,
        "threads": threads == null ? [] : List<dynamic>.from(threads!.map((x) => x)),
        "username": username,
    };
}


/// The complete SurrealDB schema definition.
/// This constant contains the raw .surql schema file content.
const String SURQL_SCHEMA = "-- ##################################################################
-- SCOPES & AUTHENTICATION
-- ##################################################################

DEFINE FUNCTION fn::polyfill::createAccount(\$username: string, \$password: string) {
  IF string::len(\$username) <= 3 { THROW \"Username must be longer than 3 characters\" };
  IF string::len(\$password) == 0 { THROW \"Password cannot be empty\" };

  LET \$existing = (SELECT value id FROM user WHERE username = \$username LIMIT 1)[0];
  IF \$existing != NONE { THROW \"Username '\" + <string>\$username + \"' is already taken\" };

  LET \$u = (CREATE user SET username = \$username, password = crypto::argon2::generate(\$password))[0];
  RETURN \$u;
};

-- ##################################################################
-- USER TABLE
-- ##################################################################

DEFINE TABLE user SCHEMAFULL
PERMISSIONS FOR select, create, update, delete WHERE true;

DEFINE FIELD username ON TABLE user TYPE string
ASSERT \$value != NONE AND string::len(\$value) > 3
PERMISSIONS FOR select, create, update WHERE true;
    
DEFINE INDEX unique_username ON TABLE user FIELDS username UNIQUE;



-- ##################################################################
-- THREAD TABLE
-- ##################################################################

DEFINE TABLE thread SCHEMAFULL
PERMISSIONS FOR select, create, update, delete WHERE true
;


DEFINE FIELD title ON TABLE thread TYPE string
    ASSERT \$value != NONE AND string::len(\$value) > 0 AND string::len(\$value) <= 200;

DEFINE FIELD content ON TABLE thread TYPE string
    ASSERT \$value != NONE AND string::len(\$value) > 0;

DEFINE FIELD author ON TABLE thread TYPE record<user>; -- @parent

DEFINE FIELD created_at ON TABLE thread TYPE datetime
    VALUE time::now();

DEFINE FIELD active ON TABLE thread TYPE bool VALUE \$value OR false;

-- ##################################################################
-- COMMENT TABLE
-- ##################################################################

DEFINE TABLE comment SCHEMAFULL
PERMISSIONS FOR select, create, update, delete WHERE true
;

DEFINE FIELD thread ON TABLE comment TYPE record<thread>; -- @parent

DEFINE FIELD content ON TABLE comment TYPE string
    ASSERT \$value != NONE AND string::len(\$value) > 0;

DEFINE FIELD author ON TABLE comment TYPE record<user>;

DEFINE FIELD created_at ON TABLE comment TYPE datetime
    VALUE time::now();

-- ##################################################################
-- RELATION TABLES
-- ##################################################################

DEFINE TABLE commented_on SCHEMAFULL TYPE RELATION
  FROM comment TO thread
PERMISSIONS FOR select, create, update, delete WHERE true;

DEFINE EVENT comment_created ON TABLE comment WHEN \$event = \"CREATE\" THEN
  RELATE (\$after.id)->commented_on->(\$after.thread)
;
-- ==================================================
-- SPOOKY INCANTATION
-- The Registry of active Live Queries (Incantations).
-- ==================================================

DEFINE TABLE _spooky_incantation SCHEMALESS
PERMISSIONS FOR select, create, update, delete WHERE true;

-- The raw query string (for re-hydration/debugging)
-- The raw query string (for re-hydration/debugging)
DEFINE FIELD surrealQL ON TABLE _spooky_incantation TYPE option<string>
PERMISSIONS FOR select, create, update WHERE true;

-- The raw query string (for re-hydration/debugging)
DEFINE FIELD clientId ON TABLE _spooky_incantation TYPE option<string>
PERMISSIONS FOR select, create, update WHERE true;

-- The current XOR sum of all results in this query
DEFINE FIELD hash ON TABLE _spooky_incantation TYPE option<string>
PERMISSIONS FOR select, create, update WHERE true;

-- The Radix Tree of Result IDs for efficient sync
DEFINE FIELD tree ON TABLE _spooky_incantation TYPE any
PERMISSIONS FOR select, create, update WHERE true;

-- For garbage collection (Heartbeat)
DEFINE FIELD lastActiveAt ON TABLE _spooky_incantation TYPE datetime DEFAULT time::now()
PERMISSIONS FOR select, create, update WHERE true;

-- How long this Incantation stays alive without activity
DEFINE FIELD ttl ON TABLE _spooky_incantation TYPE duration
PERMISSIONS FOR select, create, update WHERE true;


-- ==================================================
-- SPOOKY SCHEMA
-- The provisioned schema state for the database. Currently only used in local cache.
-- Used in local-migrator.ts
-- ==================================================

DEFINE TABLE IF NOT EXISTS _spooky_schema SCHEMAFULL;
DEFINE FIELD IF NOT EXISTS id ON _spooky_schema TYPE string;
DEFINE FIELD IF NOT EXISTS hash ON _spooky_schema TYPE string;
DEFINE FIELD IF NOT EXISTS created_at ON _spooky_schema TYPE datetime VALUE time::now();
DEFINE INDEX IF NOT EXISTS unique_hash ON _spooky_schema FIELDS hash UNIQUE;

-- ==================================================
-- SPOOKY STREAM PROCESSOR STATE
-- Stores the local state of the stream processor (DBSP)
-- ==================================================

DEFINE TABLE IF NOT EXISTS _spooky_stream_processor_state SCHEMALESS
PERMISSIONS FOR select, create, update, delete WHERE true;

DEFINE FIELD IF NOT EXISTS id ON _spooky_stream_processor_state TYPE string;
DEFINE FIELD IF NOT EXISTS state ON _spooky_stream_processor_state TYPE string;
DEFINE FIELD IF NOT EXISTS updated_at ON _spooky_stream_processor_state TYPE datetime VALUE time::now();

-- ==================================================
-- SPOOKY DATA HASH (Client)
-- Removed: Replaced by DBSP Module Internal Hashing
-- ==================================================

-- ==================================================
-- SPOOKY EVENTS
-- Stores create, update, and delete events
-- ==================================================

DEFINE TABLE _spooky_pending_mutations SCHEMAFULL
PERMISSIONS FOR select, create, update, delete WHERE true;

DEFINE FIELD IF NOT EXISTS id ON _spooky_pending_mutations TYPE string;

DEFINE FIELD IF NOT EXISTS mutationType ON _spooky_pending_mutations TYPE string
PERMISSIONS FOR select, create, update WHERE true;

-- The target record ID (for update/delete) - maps to 'id' in the event object
DEFINE FIELD IF NOT EXISTS recordId ON _spooky_pending_mutations TYPE option<record>
PERMISSIONS FOR select, create, update WHERE true;

-- The data payload (for create/update)
DEFINE FIELD IF NOT EXISTS data ON _spooky_pending_mutations TYPE option<object> FLEXIBLE
PERMISSIONS FOR select, create, update WHERE true;


-- ==================================================
-- AUTO-GENERATED SPOOKY EVENTS
-- ==================================================

-- Table: comment Client Mutation
DEFINE EVENT OVERWRITE _spooky_comment_client_mutation ON TABLE comment
WHEN \$before != \$after AND \$event != \"DELETE\"
THEN {
    -- No-op for now. Client mutation sync logic moved to DBSP.
};

-- Table: comment Client Deletion
DEFINE EVENT OVERWRITE _spooky_comment_client_delete ON TABLE comment
WHEN \$event = \"DELETE\"
THEN {
    -- No-op for now.
};

-- Table: thread Client Mutation
DEFINE EVENT OVERWRITE _spooky_thread_client_mutation ON TABLE thread
WHEN \$before != \$after AND \$event != \"DELETE\"
THEN {
    -- No-op for now. Client mutation sync logic moved to DBSP.
};

-- Table: thread Client Deletion
DEFINE EVENT OVERWRITE _spooky_thread_client_delete ON TABLE thread
WHEN \$event = \"DELETE\"
THEN {
    -- No-op for now.
};

-- Table: user Client Mutation
DEFINE EVENT OVERWRITE _spooky_user_client_mutation ON TABLE user
WHEN \$before != \$after AND \$event != \"DELETE\"
THEN {
    -- No-op for now. Client mutation sync logic moved to DBSP.
};

-- Table: user Client Deletion
DEFINE EVENT OVERWRITE _spooky_user_client_delete ON TABLE user
WHEN \$event = \"DELETE\"
THEN {
    -- No-op for now.
};
";
