use anyhow::{Context, Result};
use std::fs;
use std::process::Command;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum OutputFormat {
    JsonSchema,
    Typescript,
    Dart,
    Surql,
}

impl OutputFormat {
    pub fn from_extension(path: &str) -> Option<Self> {
        if path.ends_with(".json") {
            Some(Self::JsonSchema)
        } else if path.ends_with(".ts") {
            Some(Self::Typescript)
        } else if path.ends_with(".dart") {
            Some(Self::Dart)
        } else if path.ends_with(".surql") {
            Some(Self::Surql)
        } else {
            None
        }
    }
}

pub struct CodeGenerator {
    format: OutputFormat,
    include_header: bool,
}

impl CodeGenerator {
    pub fn new_with_header(format: OutputFormat, include_header: bool) -> Self {
        Self {
            format,
            include_header,
        }
    }

    pub fn generate(&self, json_schema_content: &str, _top_level_name: &str) -> Result<String> {
        self.generate_with_schema(json_schema_content, _top_level_name, None, None)
    }

    pub fn generate_with_schema(
        &self,
        json_schema_content: &str,
        _top_level_name: &str,
        raw_schema: Option<&str>,
        spooky_events: Option<&str>,
    ) -> Result<String> {
        let mut content = match self.format {
            OutputFormat::JsonSchema => json_schema_content.to_string(),
            OutputFormat::Typescript => self.generate_typescript(json_schema_content)?,
            OutputFormat::Dart => self.generate_dart(json_schema_content)?,
            OutputFormat::Surql => {
                let mut schema = String::new();

                // Add module definitions section
                schema.push_str("\n-- ==================================================\n");
                schema.push_str("-- SURREALISM MODULES\n");
                schema.push_str("-- ==================================================\n");
                schema.push_str("\n-- Define bucket for module files\n");
                schema.push_str("DEFINE BUCKET IF NOT EXISTS modules BACKEND \"file:/modules\";\n\n");
                schema.push_str("-- Define the XOR module\n");
                schema.push_str("DEFINE MODULE mod::xor AS f\"modules:/xor_module.surli\";\n\n");
                schema.push_str("-- Define the DBSP module\n");
                schema.push_str("DEFINE MODULE mod::dbsp AS f\"modules:/dbsp_module.surli\";\n\n");

                // Add the main schema content
                schema.push_str(raw_schema.unwrap_or(""));

                // Add spooky events at the end
                if let Some(events) = spooky_events {
                    schema.push_str(events);
                }
                schema
            },
        };

        if self.include_header {
            let header = self.generate_header();
            content = format!("{}\n{}", header, content);
        }

        // Add raw schema constant for TypeScript and Dart
        if let Some(schema) = raw_schema {
            let full_schema = if let Some(events) = spooky_events {
                format!("{}\n\n{}", schema, events)
            } else {
                schema.to_string()
            };
            content = self.add_schema_constant(content, &full_schema)?;
        }

        Ok(content)
    }

    fn generate_typescript(&self, json_schema_content: &str) -> Result<String> {
        println!("Generating TypeScript from JSON schema...");

        // Generate only the schema metadata - no interfaces
        println!("Adding schema metadata...");
        let output_with_metadata = self.add_schema_metadata("", json_schema_content)?;
        Ok(output_with_metadata)
    }

    fn generate_dart(&self, json_schema_content: &str) -> Result<String> {
        self.run_quicktype(json_schema_content, "dart")
    }

    fn generate_header(&self) -> String {
        match self.format {
            OutputFormat::Typescript => {
                "// This file is auto-generated. Do not edit manually.\n// Generated by syncgen - any changes will be overwritten.\n".to_string()
            }
            OutputFormat::Dart => {
                "// This file is auto-generated. Do not edit manually.\n// Generated by syncgen - any changes will be overwritten.\n".to_string()
            }
            OutputFormat::JsonSchema => {
                // JSON doesn't support comments, so we skip the header
                String::new()
            }
            OutputFormat::Surql => {
                "-- This file is auto-generated. Do not edit manually.\n-- Generated by syncgen - any changes will be overwritten.\n".to_string()
            }
        }
    }

    fn run_quicktype(&self, json_schema_content: &str, lang: &str) -> Result<String> {
        // Create a temporary file for the JSON schema
        let temp_dir = std::env::temp_dir();
        let schema_path = temp_dir.join("schema.json");

        fs::write(&schema_path, json_schema_content)
            .context("Failed to write temporary schema file")?;

        // Build arguments based on language
        let mut args = vec!["-y", "quicktype", "--src-lang", "schema", "--lang", lang];

        // Add --just-types for TypeScript to exclude runtime validation code
        if lang == "typescript" {
            args.push("--just-types");
        }

        args.push(schema_path.to_str().unwrap());

        // Run quicktype
        let output = Command::new("npx")
            .args(&args)
            .output()
            .context("Failed to execute quicktype. Make sure npx is installed.")?;

        // Clean up temp file
        let _ = fs::remove_file(&schema_path);

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            anyhow::bail!("quicktype failed: {}", stderr);
        }

        let code =
            String::from_utf8(output.stdout).context("quicktype output is not valid UTF-8")?;

        Ok(code)
    }

    fn remove_top_level_schema_interface(&self, content: String) -> String {
        let lines: Vec<&str> = content.lines().collect();
        let mut result = Vec::new();
        let mut i = 0;
        let mut skip_until_closing_brace = false;
        let mut brace_count = 0;

        while i < lines.len() {
            let line = lines[i];

            // Check if this is the top-level Schema interface with an exact match
            // We only want to remove "export interface Schema {" not "export interface SchemaFoo {"
            if line.trim() == "export interface Schema {" ||
               (line.trim().starts_with("export interface Schema") &&
                (line.trim().ends_with("{") || !line.contains("{"))) {
                // Check if it's exactly "Schema" and not "SchemaSomething"
                let after_interface = line.split("export interface").nth(1).unwrap_or("");
                let interface_name = after_interface.trim().split_whitespace().next().unwrap_or("");

                if interface_name == "Schema" || interface_name == "Schema{" {
                    // Start skipping lines and track braces
                    skip_until_closing_brace = true;
                    brace_count = 0;

                    // Count braces in the current line
                    for ch in line.chars() {
                        if ch == '{' {
                            brace_count += 1;
                        } else if ch == '}' {
                            brace_count -= 1;
                        }
                    }

                    i += 1;

                    // If we already closed on the same line, we're done
                    if brace_count == 0 && line.contains("}") {
                        skip_until_closing_brace = false;
                        // Skip any trailing empty lines
                        while i < lines.len() && lines[i].trim().is_empty() {
                            i += 1;
                        }
                    }
                    continue;
                }
            }

            if skip_until_closing_brace {
                // Count braces to find the end of the interface
                for ch in line.chars() {
                    if ch == '{' {
                        brace_count += 1;
                    } else if ch == '}' {
                        brace_count -= 1;
                    }
                }

                // If we've closed all braces, we're done with this interface
                if brace_count <= 0 {
                    skip_until_closing_brace = false;
                    i += 1;
                    // Skip any trailing empty lines
                    while i < lines.len() && lines[i].trim().is_empty() {
                        i += 1;
                    }
                    continue;
                }

                i += 1;
                continue;
            }

            result.push(line);
            i += 1;
        }

        result.join("\n")
    }

    fn add_index_signature_to_interfaces(&self, content: String) -> String {
        // NOTE: This function is now used to REMOVE index signatures, not add them.
        // Index signatures like [property: string]: any are intentionally removed
        // because they break TypeScript's type inference when using mapped types.
        // This allows proper type narrowing in generic contexts like TableQueries<Schema>.

        let lines: Vec<&str> = content.lines().collect();
        let mut result = Vec::new();

        for line in lines {
            // Skip lines that contain index signatures
            if line.trim().starts_with("[property:") && line.contains("]:") {
                continue;
            }
            result.push(line);
        }

        result.join("\n")
    }

    fn add_schema_metadata(&self, content: &str, json_schema_content: &str) -> Result<String> {
        // Parse JSON schema to extract schema information
        let schema: serde_json::Value = serde_json::from_str(json_schema_content)
            .context("Failed to parse JSON schema")?;

        // Build tables array - start without empty line prefix
        let mut tables_lines = vec![
            "export const schema = {".to_string(),
            "  tables: [".to_string(),
        ];

        if let Some(definitions) = schema.get("definitions") {
            if let serde_json::Value::Object(defs_obj) = definitions {
                // Process each table (skip Relationships and RelationTables)
                for (table_name, table_def) in defs_obj {
                    if table_name == "Relationships" || table_name == "RelationTables" || table_name.starts_with("_spooky_") {
                        continue;
                    }

                    tables_lines.push("    {".to_string());
                    tables_lines.push(format!("      name: '{}' as const,", table_name));
                    tables_lines.push("      columns: {".to_string());

                    // Extract columns from properties
                    if let Some(props) = table_def.get("properties") {
                        if let serde_json::Value::Object(props_obj) = props {
                            for (col_name, col_def) in props_obj {
                                let col_type = self.map_json_schema_type_to_value_type(col_def);
                                let is_optional = self.is_field_optional(table_def, col_name);
                                let is_record_id = col_def.get("x-is-record-id")
                                    .and_then(|v| v.as_bool())
                                    .unwrap_or(false);
                                let is_datetime = col_def.get("x-is-datetime")
                                    .and_then(|v| v.as_bool())
                                    .unwrap_or(false);

                                let clean_col_name = col_name.replace("`", "");

                                let mut flags = Vec::new();
                                if is_record_id {
                                    flags.push("recordId: true");
                                }
                                if is_datetime {
                                    flags.push("dateTime: true");
                                }

                                if flags.is_empty() {
                                    tables_lines.push(format!(
                                        "        {}: {{ type: '{}' as const, optional: {} }},",
                                        clean_col_name, col_type, is_optional
                                    ));
                                } else {
                                    tables_lines.push(format!(
                                        "        {}: {{ type: '{}' as const, {}, optional: {} }},",
                                        clean_col_name, col_type, flags.join(", "), is_optional
                                    ));
                                }
                            }
                        }
                    }

                    tables_lines.push("      },".to_string());
                    tables_lines.push("      primaryKey: ['id'] as const".to_string());
                    tables_lines.push("    },".to_string());
                }
            }
        }

        tables_lines.push("  ],".to_string());

        // Build relationships array
        tables_lines.push("  relationships: [".to_string());

        // Extract relationship data using the existing logic
        let table_relationships = self.extract_table_relationships(&schema)?;

        for (table_name, rels) in &table_relationships {
            for (field_name, related_table, cardinality) in rels {
                tables_lines.push("    {".to_string());
                tables_lines.push(format!("      from: '{}' as const,", table_name));
                tables_lines.push(format!("      field: '{}' as const,", field_name));
                tables_lines.push(format!("      to: '{}' as const,", related_table));
                tables_lines.push(format!("      cardinality: '{}' as const", cardinality));
                tables_lines.push("    },".to_string());
            }
        }

        tables_lines.push("  ]".to_string());
        tables_lines.push("} as const;".to_string());
        tables_lines.push("".to_string());

        // Add derived type
        tables_lines.push("export type SchemaDefinition = typeof schema;".to_string());
        tables_lines.push("".to_string());

        if content.is_empty() {
            Ok(tables_lines.join("\n"))
        } else {
            Ok(format!("{}\n\n{}", content, tables_lines.join("\n")))
        }
    }

    fn map_json_schema_type_to_value_type(&self, field_def: &serde_json::Value) -> &str {
        if let Some(field_type) = field_def.get("type") {
            match field_type {
                serde_json::Value::String(type_str) => match type_str.as_str() {
                    "string" => "string",
                    "number" | "integer" => "number",
                    "boolean" => "boolean",
                    _ => "string",
                },
                serde_json::Value::Array(types) => {
                    // Handle union types like ["string", "null"]
                    for t in types {
                        if let serde_json::Value::String(type_str) = t {
                            if type_str != "null" {
                                return match type_str.as_str() {
                                    "string" => "string",
                                    "number" | "integer" => "number",
                                    "boolean" => "boolean",
                                    _ => "string",
                                };
                            }
                        }
                    }
                    "string"
                }
                _ => "string",
            }
        } else {
            "string"
        }
    }

    fn is_field_optional(&self, table_def: &serde_json::Value, field_name: &str) -> bool {
        // Check if field is in required array
        if let Some(required) = table_def.get("required") {
            if let serde_json::Value::Array(req_array) = required {
                return !req_array.iter().any(|v| {
                    if let serde_json::Value::String(s) = v {
                        s == field_name
                    } else {
                        false
                    }
                });
            }
        }
        true // If no required array, assume optional
    }

    fn extract_table_relationships(&self, schema: &serde_json::Value) -> Result<std::collections::HashMap<String, Vec<(String, String, String)>>> {
        let mut table_relationships = std::collections::HashMap::new();

        if let Some(defs) = schema.get("definitions") {
            if let serde_json::Value::Object(defs_obj) = defs {
                for (table_name, table_def) in defs_obj {
                    if table_name == "Relationships" || table_name == "RelationTables" || table_name.starts_with("_spooky_") {
                        continue;
                    }

                    if let Some(props) = table_def.get("properties") {
                        if let serde_json::Value::Object(props_obj) = props {
                            let mut table_rels = Vec::new();

                            for (field_name, field_def) in props_obj {
                                let is_array = if let Some(array_type) = field_def.get("type") {
                                    if array_type == "array" {
                                        true
                                    } else if let serde_json::Value::Array(types) = array_type {
                                        types.iter().any(|t| t == "array")
                                    } else {
                                        false
                                    }
                                } else {
                                    false
                                };

                                if is_array {
                                    if let Some(items) = field_def.get("items") {
                                        if let Some(desc) = items.get("description") {
                                            if let Some(desc_str) = desc.as_str() {
                                                if desc_str.starts_with("Record ID of table: ") {
                                                    let related_table = desc_str.replace("Record ID of table: ", "");
                                                    let actual_target = if related_table == "commented_on" {
                                                        "comment".to_string()
                                                    } else {
                                                        related_table.clone()
                                                    };
                                                    table_rels.push((field_name.clone(), actual_target, "many".to_string()));
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if let Some(desc) = field_def.get("description") {
                                        if let Some(desc_str) = desc.as_str() {
                                            if desc_str.starts_with("Record ID of table: ") {
                                                let related_table = desc_str.replace("Record ID of table: ", "");
                                                table_rels.push((field_name.clone(), related_table, "one".to_string()));
                                            }
                                        }
                                    }
                                }
                            }

                            if !table_rels.is_empty() {
                                table_relationships.insert(table_name.clone(), table_rels);
                            }
                        }
                    }
                }
            }
        }

        // Reverse relationships are now added as virtual fields in table definitions,
        // so they will be extracted by the field-based extraction above

        Ok(table_relationships)
    }

    fn add_relationships_interface(&self, content: &str, json_schema_content: &str) -> Result<String> {
        // Parse JSON schema to extract relationships
        let schema: serde_json::Value = serde_json::from_str(json_schema_content)
            .context("Failed to parse JSON schema")?;

        let relationships = schema
            .get("definitions")
            .and_then(|defs| defs.get("Relationships"))
            .and_then(|rel| rel.get("properties"));

        // Extract relation tables
        let _relation_tables = schema
            .get("definitions")
            .and_then(|defs| defs.get("RelationTables"))
            .and_then(|rel| rel.get("const"));

        if let Some(relationships) = relationships {
            if let serde_json::Value::Object(rel_map) = relationships {
                // First, extract the actual relationship data from the schema
                let table_relationships = schema
                    .get("definitions")
                    .and_then(|defs| {
                        // Collect relationships from each table definition
                        let mut all_rels = std::collections::HashMap::new();
                        if let serde_json::Value::Object(defs_obj) = defs {
                            println!("Processing definitions, found {} tables", defs_obj.len());
                            for (table_name, table_def) in defs_obj {
                                if table_name == "Relationships" || table_name.starts_with("_spooky_") {
                                    continue;
                                }
                                // Check if this table has any record fields
                                if let Some(props) = table_def.get("properties") {
                                    if let serde_json::Value::Object(props_obj) = props {
                                        let mut table_rels = Vec::new();
                                        for (field_name, field_def) in props_obj {
                                            // Check for array of records (including nullable arrays)
                                            let is_array = if let Some(array_type) = field_def.get("type") {
                                                if array_type == "array" {
                                                    true
                                                } else if let serde_json::Value::Array(types) = array_type {
                                                    // Handle nullable types like ["array", "null"]
                                                    types.iter().any(|t| t == "array")
                                                } else {
                                                    false
                                                }
                                            } else {
                                                false
                                            };
                                            
                                            // Debug output
                                            println!("Field: {}, Type: {:?}, Is array: {}", field_name, field_def.get("type"), is_array);

                                            if is_array {
                                                if let Some(items) = field_def.get("items") {
                                                    if let Some(desc) = items.get("description") {
                                                        if let Some(desc_str) = desc.as_str() {
                                                            if desc_str.starts_with("Record ID of table: ") {
                                                                let related_table = desc_str.replace("Record ID of table: ", "");
                                                                
                                                                // Check if this is a junction table (relation table)
                                                                // If so, we need to find the actual target table
                                                                let actual_target = if related_table.ends_with("_on") || related_table.contains("relation") {
                                                                    // This is likely a junction table, try to find the actual target
                                                                    // For now, we'll use a simple heuristic: if it's commented_on, target is comment
                                                                    if related_table == "commented_on" {
                                                                        "comment".to_string()
                                                                    } else {
                                                                        related_table.clone()
                                                                    }
                                                                } else {
                                                                    related_table.clone()
                                                                };
                                                                
                                                                // Debug output
                                                                println!("Field: {}, Original table: {}, Actual target: {}", field_name, related_table, actual_target);
                                                                
                                                                // This is a 1:many relationship (array)
                                                                table_rels.push((field_name.clone(), actual_target, "many".to_string()));
                                                            }
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Check if this is a single record field (1:1)
                                                if let Some(desc) = field_def.get("description") {
                                                    if let Some(desc_str) = desc.as_str() {
                                                        if desc_str.starts_with("Record ID of table: ") {
                                                            let related_table = desc_str.replace("Record ID of table: ", "");
                                                            // This is a 1:1 relationship (single value)
                                                            table_rels.push((field_name.clone(), related_table, "one".to_string()));
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        if !table_rels.is_empty() {
                                            all_rels.insert(table_name.clone(), table_rels);
                                        }
                                    }
                                }
                            }
                        }
                        Some(all_rels)
                    });

                // Now update the interface definitions to use proper relationship types
                let updated_content = if let Some(ref table_rels) = table_relationships {
                    self.update_interface_relationships(content, table_rels)?
                } else {
                    content.to_string()
                };

                // Generate the interface lines
                let mut interface_lines = vec![
                    "/**".to_string(),
                    " * Relationship definition for a single relationship field".to_string(),
                    " */".to_string(),
                    "export interface RelationshipDefinition<Model = any> {".to_string(),
                    "    /** The related model type */".to_string(),
                    "    model: Model;".to_string(),
                    "    /** The related table name */".to_string(),
                    "    table: string;".to_string(),
                    "    /** Whether this is a 1:1 or 1:many relationship */".to_string(),
                    "    cardinality: \"one\" | \"many\";".to_string(),
                    "}".to_string(),
                    "".to_string(),
                    "/**".to_string(),
                    " * Relationships between tables - nested object structure".to_string(),
                    " * Maps each table to its relationship fields with their definitions".to_string(),
                    " */".to_string(),
                    "export interface Relationships {".to_string(),
                ];

                // Generate nested interface structure
                if let Some(ref table_rels) = table_relationships {
                    for (table_name, rels) in table_rels {
                        if rels.is_empty() {
                            interface_lines.push(format!("    {}: {{}};", table_name));
                        } else {
                            interface_lines.push(format!("    {}: {{", table_name));
                            for (field_name, related_table, cardinality) in rels {
                                interface_lines.push(format!("        {}: {{", field_name));
                                interface_lines.push(format!("            model: SchemaDefinition[\"{}\"];", related_table));
                                interface_lines.push(format!("            table: \"{}\";", related_table));
                                interface_lines.push(format!("            cardinality: \"{}\";", cardinality));
                                interface_lines.push("        };".to_string());
                            }
                            interface_lines.push("    };".to_string());
                        }
                    }
                } else {
                    for (table_name, _rel_data) in rel_map {
                        interface_lines.push(format!("    {}: {{}};", table_name));
                    }
                }

                interface_lines.push("}".to_string());
                interface_lines.push("".to_string());

                // RELATIONSHIPS constant removed - relationships are type-only now
                // The Relationships interface above provides type safety without runtime overhead

                // RELATION_TABLES constant also removed - not needed for runtime

                return Ok(format!("{}\n\n{}\n", updated_content, interface_lines.join("\n")));
            }
        }

        // No relationships found, return original content
        Ok(content.to_string())
    }

    fn update_interface_relationships(&self, content: &str, table_relationships: &std::collections::HashMap<String, Vec<(String, String, String)>>) -> Result<String> {
        let lines: Vec<&str> = content.lines().collect();
        let mut result = Vec::new();
        let mut i = 0;

        while i < lines.len() {
            let line = lines[i];
            
            // Check if this line starts an interface definition
            if line.trim_start().starts_with("export interface ") {
                let interface_name = line
                    .split_whitespace()
                    .nth(2)
                    .unwrap_or("")
                    .trim_end_matches(" {");
                
                // Check if this interface has relationships we need to update
                if let Some(relationships) = table_relationships.get(interface_name) {
                    result.push(line.to_string());
                    
                    // Find the opening brace
                    let mut brace_found = false;
                    let mut j = i;
                    
                    while j < lines.len() && !brace_found {
                        if lines[j].contains("{") {
                            brace_found = true;
                            
                            // If opening brace is not on the same line, add those lines too
                            if j > i {
                                for k in (i + 1)..=j {
                                    result.push(lines[k].to_string());
                                }
                                i = j;
                            }
                        }
                        j += 1;
                    }
                    
                    // Now find the closing brace and update relationship fields
                    if brace_found {
                        let mut brace_count = 0;
                        let mut started = false;
                        let mut closing_line_idx = i;
                        
                        for k in i..lines.len() {
                            for ch in lines[k].chars() {
                                if ch == '{' {
                                    brace_count += 1;
                                    started = true;
                                } else if ch == '}' {
                                    brace_count -= 1;
                                    if started && brace_count == 0 {
                                        closing_line_idx = k;
                                        break;
                                    }
                                }
                            }
                            if started && brace_count == 0 {
                                break;
                            }
                        }
                        
                        // Process lines within the interface
                        for k in (i + 1)..closing_line_idx {
                            let current_line = lines[k];
                            let mut updated_line = current_line.to_string();
                            
                            // Check if this line contains a relationship field
                            for (field_name, related_table, cardinality) in relationships {
                                if current_line.contains(field_name) {
                                    // Update the field type based on cardinality
                                    if cardinality == "many" {
                                        // For many relationships, use array of related type
                                        if current_line.contains("string[]") {
                                            updated_line = current_line.replace("string[]", &format!("SchemaDefinition[\"{}\"][]", related_table));
                                        } else if current_line.contains("string") {
                                            updated_line = current_line.replace("string", &format!("SchemaDefinition[\"{}\"][]", related_table));
                                        }

                                        // Handle nullable arrays
                                        if current_line.contains("| null") {
                                            updated_line = updated_line.replace(
                                                &format!("SchemaDefinition[\"{}\"][]", related_table),
                                                &format!("SchemaDefinition[\"{}\"][] | null", related_table)
                                            );
                                        }
                                    } else {
                                        // For one relationships, use single related type
                                        if current_line.contains("string") {
                                            updated_line = current_line.replace("string", &format!("SchemaDefinition[\"{}\"]", related_table));
                                        }

                                        // Handle nullable single values
                                        if current_line.contains("| null") {
                                            updated_line = updated_line.replace(
                                                &format!("SchemaDefinition[\"{}\"]", related_table),
                                                &format!("SchemaDefinition[\"{}\"] | null", related_table)
                                            );
                                        }
                                    }
                                }
                            }
                            
                            result.push(updated_line);
                        }
                        
                        // Add the closing brace
                        result.push(lines[closing_line_idx].to_string());
                        i = closing_line_idx;
                    }
                } else {
                    // No relationships for this interface, add as-is
                    result.push(line.to_string());
                }
            } else {
                result.push(line.to_string());
            }
            
            i += 1;
        }
        
        Ok(result.join("\n"))
    }

    fn add_schema_constant(&self, content: String, schema: &str) -> Result<String> {
        match self.format {
            OutputFormat::Typescript => {
                // Escape the schema content for TypeScript template literal
                let filtered_schema = self.filter_client_schema(schema);
                let escaped_schema = filtered_schema.replace("\\", "\\\\").replace("`", "\\`");

                Ok(format!(
                    "{}\n\n/**\n * The complete SurrealDB schema definition.\n * This constant contains the raw .surql schema file content.\n */\nexport const SURQL_SCHEMA = `{}`;\n",
                    content, escaped_schema
                ))
            }
            OutputFormat::Dart => {
                // Escape the schema content for Dart string literal
                let filtered_schema = self.filter_client_schema(schema);
                let escaped_schema = filtered_schema
                    .replace("\\", "\\\\")
                    .replace("\"", "\\\"")
                    .replace("$", "\\$");

                Ok(format!(
                    "{}\n\n/// The complete SurrealDB schema definition.\n/// This constant contains the raw .surql schema file content.\nconst String SURQL_SCHEMA = \"{}\";\n",
                    content, escaped_schema
                ))
            }
            OutputFormat::JsonSchema | OutputFormat::Surql => {
                // For JSON and Surql, we don't add a schema constant
                Ok(content)
            }
        }
    }

    fn filter_client_schema(&self, schema: &str) -> String {
        let lines: Vec<&str> = schema.lines().collect();
        let mut result = Vec::new();
        let mut i = 0;
        let mut in_define_access = false;
        let mut access_brace_count = 0;
        let mut skip_permissions = false;

        let mut def_type = "TABLE";

        while i < lines.len() {
            let line = lines[i];
            
            // Strip comments to correctly check for semicolons
            let clean_line = if let Some(idx) = line.find("--") {
                &line[..idx]
            } else if let Some(idx) = line.find("//") {
                &line[..idx]
            } else if let Some(idx) = line.find('#') {
                &line[..idx]
            } else {
                line
            };
            
            let trimmed = clean_line.trim();

            // Skip empty lines (were just comments or whitespace)
            if trimmed.is_empty() {
                // If we are skipping a permissions block, and we hit an empty line,
                // we should check if the PREVIOUS line ended with semicolon?
                // Or does semicolon end the block immediately?
                // Logic:
                // if trimmed.ends_with(';') { replacement.push(';') } else { skip_permissions = true }
                // So if we are in skip_permissions mode, we look for ';'.
                // If line is empty, just continue.
                
                // But wait, if we are NOT in skip_permissions mode, we might want to preserve comments?
                // The logical flow below pushes `result.push(line.to_string())` at the end.
                // If I change `trimmed` to be comment-free, I might lose comments in output?
                // The task is to GENERATE valid schema. Comments valid.
                // But for LOGIC CHECKS, use `trimmed`.
                // For OUTPUT, use `line`.
                
                // Let's use `trimmed` for logic, keep `line` for output unless replacing.
                
                // BUT if I skip empty lines here, I lose them. I should proceed.
            }

            let full_trimmed = line.trim(); // For checks that might need full line? 
            // Actually, matching "DEFINE TABLE" should use stripped line?
            // "DEFINE TABLE foo -- comment" -> "DEFINE TABLE foo". Matches.
            // So using `trimmed` (clean) is better.

            // Handle DEFINE ACCESS removal
            if trimmed.to_uppercase().starts_with("DEFINE ACCESS") {
                in_define_access = true;
                access_brace_count = 0;
                // Count braces in the start line
                for ch in trimmed.chars() {
                    if ch == '{' { access_brace_count += 1; }
                    else if ch == '}' { access_brace_count -= 1; }
                }

                if access_brace_count == 0 && trimmed.ends_with(';') {
                    in_define_access = false;
                }
                i += 1;
                continue;
            }

            if in_define_access {
                for ch in trimmed.chars() {
                    if ch == '{' { access_brace_count += 1; }
                    else if ch == '}' { access_brace_count -= 1; }
                }

                if access_brace_count == 0 && trimmed.ends_with(';') {
                    in_define_access = false;
                }
                i += 1;
                continue;
            }

            // Track definition type
            if trimmed.to_uppercase().starts_with("DEFINE TABLE") {
                def_type = "TABLE";
            } else if trimmed.to_uppercase().starts_with("DEFINE FIELD") {
                def_type = "FIELD";
            }

            // Handle PERMISSIONS replacement
            // Match PERMISSIONS at start of line (for TABLE/FIELD)
            if trimmed.to_uppercase().starts_with("PERMISSIONS") {
                let perms = if def_type == "TABLE" {
                    "PERMISSIONS FOR select, create, update, delete WHERE true"
                } else {
                    "PERMISSIONS FOR select, create, update WHERE true"
                };
                let mut replacement = perms.to_string();
                
                if trimmed.ends_with(';') {
                    replacement.push(';');
                } else {
                    // It's a block, skip subsequent lines properly
                    skip_permissions = true;
                }
                
                result.push(replacement);
                i += 1;
                continue;
            }

            // If we are inside a permissions block, skip lines starting with FOR
            if skip_permissions {
                // If the line is just a comment, we ignore it for semicolon checking
                if trimmed.is_empty() {
                    i += 1;
                    continue;
                }

                if trimmed.to_uppercase().starts_with("FOR") {
                     // Check if this is the last line of permissions (ends with semicolon)
                     if trimmed.ends_with(';') {
                         skip_permissions = false;
                         // We consumed the line with semicolon, so we must add it to our replacement
                         if let Some(last) = result.last_mut() {
                             last.push(';');
                         }
                     }
                     i += 1;
                     continue;
                } else {
                    // We encountered something that is NOT a FOR line.
                    // This implies the permissions block ended (perhaps implicitly or we misjudged).
                    skip_permissions = false;
                    
                    // IMPORTANT: If we misjudged, we might be on a new definition line.
                    // We should NOT suppress it. 
                    // Fall through to result.push(line).
                }
            }
            
            result.push(line.to_string());
            i += 1;
        }

        result.join("\n")
    }
}
