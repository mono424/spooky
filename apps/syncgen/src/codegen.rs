use anyhow::{Context, Result};
use std::fs;
use std::process::Command;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum OutputFormat {
    JsonSchema,
    Typescript,
    Dart,
}

impl OutputFormat {
    pub fn from_extension(path: &str) -> Option<Self> {
        if path.ends_with(".json") {
            Some(Self::JsonSchema)
        } else if path.ends_with(".ts") {
            Some(Self::Typescript)
        } else if path.ends_with(".dart") {
            Some(Self::Dart)
        } else {
            None
        }
    }
}

pub struct CodeGenerator {
    format: OutputFormat,
    include_header: bool,
}

impl CodeGenerator {
    pub fn new_with_header(format: OutputFormat, include_header: bool) -> Self {
        Self {
            format,
            include_header,
        }
    }

    pub fn generate(&self, json_schema_content: &str, _top_level_name: &str) -> Result<String> {
        self.generate_with_schema(json_schema_content, _top_level_name, None)
    }

    pub fn generate_with_schema(
        &self,
        json_schema_content: &str,
        _top_level_name: &str,
        raw_schema: Option<&str>,
    ) -> Result<String> {
        let mut content = match self.format {
            OutputFormat::JsonSchema => json_schema_content.to_string(),
            OutputFormat::Typescript => self.generate_typescript(json_schema_content)?,
            OutputFormat::Dart => self.generate_dart(json_schema_content)?,
        };

        if self.include_header {
            let header = self.generate_header();
            content = format!("{}\n{}", header, content);
        }

        // Add raw schema constant for TypeScript and Dart
        if let Some(schema) = raw_schema {
            content = self.add_schema_constant(content, schema)?;
        }

        Ok(content)
    }

    fn generate_typescript(&self, json_schema_content: &str) -> Result<String> {
        println!("Generating TypeScript from JSON schema...");
        let output = self.run_quicktype(json_schema_content, "typescript")?;
        let output_with_signatures = self.add_index_signature_to_interfaces(output);

        // Add Relationships interface from schema
        println!("Adding relationships interface...");
        let output_with_relationships = self.add_relationships_interface(&output_with_signatures, json_schema_content)?;
        Ok(output_with_relationships)
    }

    fn generate_dart(&self, json_schema_content: &str) -> Result<String> {
        self.run_quicktype(json_schema_content, "dart")
    }

    fn generate_header(&self) -> String {
        match self.format {
            OutputFormat::Typescript => {
                format!(
                    "// ⚠️  WARNING: This file is automatically generated by syncgen.\n\
                     // Do not modify this file manually as changes will be overwritten.\n\
                     // To regenerate this file, run the syncgen command from the database package.\n\
                     // Generated on: {}\n",
                    chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC")
                )
            }
            OutputFormat::Dart => {
                format!(
                    "// ⚠️  WARNING: This file is automatically generated by syncgen.\n\
                     // Do not modify this file manually as changes will be overwritten.\n\
                     // To regenerate this file, run the syncgen command from the database package.\n\
                     // Generated on: {}\n",
                    chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC")
                )
            }
            OutputFormat::JsonSchema => {
                // For JSON, we'll add a comment in the schema itself
                String::new()
            }
        }
    }

    fn run_quicktype(&self, json_schema_content: &str, lang: &str) -> Result<String> {
        // Create a temporary file for the JSON schema
        let temp_dir = std::env::temp_dir();
        let schema_path = temp_dir.join("schema.json");

        fs::write(&schema_path, json_schema_content)
            .context("Failed to write temporary schema file")?;

        // Build arguments based on language
        let mut args = vec!["-y", "quicktype", "--src-lang", "schema", "--lang", lang];

        // Add --just-types for TypeScript to exclude runtime validation code
        if lang == "typescript" {
            args.push("--just-types");
        }

        args.push(schema_path.to_str().unwrap());

        // Run quicktype
        let output = Command::new("npx")
            .args(&args)
            .output()
            .context("Failed to execute quicktype. Make sure npx is installed.")?;

        // Clean up temp file
        let _ = fs::remove_file(&schema_path);

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            anyhow::bail!("quicktype failed: {}", stderr);
        }

        let code =
            String::from_utf8(output.stdout).context("quicktype output is not valid UTF-8")?;

        Ok(code)
    }

    fn add_index_signature_to_interfaces(&self, content: String) -> String {
        let lines: Vec<&str> = content.lines().collect();
        let mut result = Vec::new();
        let mut i = 0;

        while i < lines.len() {
            let line = lines[i];
            result.push(line.to_string());

            // Check if this line starts an interface definition
            if line.trim_start().starts_with("export interface ") {
                // Find the opening brace
                let mut brace_found = false;
                let mut j = i;

                while j < lines.len() && !brace_found {
                    if lines[j].contains("{") {
                        brace_found = true;

                        // If opening brace is not on the same line as we just added, add those lines too
                        if j > i {
                            for k in (i + 1)..=j {
                                result.push(lines[k].to_string());
                            }
                            i = j;
                        }
                    }
                    j += 1;
                }

                // Now find the closing brace and check if we need to add the index signature
                if brace_found {
                    let mut brace_count = 0;
                    let mut started = false;
                    let mut closing_line_idx = i;

                    for k in i..lines.len() {
                        for ch in lines[k].chars() {
                            if ch == '{' {
                                brace_count += 1;
                                started = true;
                            } else if ch == '}' {
                                brace_count -= 1;
                                if started && brace_count == 0 {
                                    closing_line_idx = k;
                                    break;
                                }
                            }
                        }
                        if started && brace_count == 0 {
                            break;
                        }
                    }

                    // Add all lines until the closing brace
                    for k in (i + 1)..closing_line_idx {
                        result.push(lines[k].to_string());
                    }

                    // NOTE: Index signatures like [property: string]: any are intentionally NOT added
                    // because they break TypeScript's type inference when using mapped types.
                    // This allows proper type narrowing in generic contexts like TableQueries<Schema>.

                    // Add the closing brace
                    result.push(lines[closing_line_idx].to_string());
                    i = closing_line_idx;
                }
            }

            i += 1;
        }

        result.join("\n")
    }

    fn add_relationships_interface(&self, content: &str, json_schema_content: &str) -> Result<String> {
        // Parse JSON schema to extract relationships
        let schema: serde_json::Value = serde_json::from_str(json_schema_content)
            .context("Failed to parse JSON schema")?;

        let relationships = schema
            .get("definitions")
            .and_then(|defs| defs.get("Relationships"))
            .and_then(|rel| rel.get("properties"));

        // Extract relation tables
        let _relation_tables = schema
            .get("definitions")
            .and_then(|defs| defs.get("RelationTables"))
            .and_then(|rel| rel.get("const"));

        if let Some(relationships) = relationships {
            if let serde_json::Value::Object(rel_map) = relationships {
                // First, extract the actual relationship data from the schema
                let table_relationships = schema
                    .get("definitions")
                    .and_then(|defs| {
                        // Collect relationships from each table definition
                        let mut all_rels = std::collections::HashMap::new();
                        if let serde_json::Value::Object(defs_obj) = defs {
                            println!("Processing definitions, found {} tables", defs_obj.len());
                            for (table_name, table_def) in defs_obj {
                                if table_name == "Relationships" {
                                    continue;
                                }
                                // Check if this table has any record fields
                                if let Some(props) = table_def.get("properties") {
                                    if let serde_json::Value::Object(props_obj) = props {
                                        let mut table_rels = Vec::new();
                                        for (field_name, field_def) in props_obj {
                                            // Check for array of records (including nullable arrays)
                                            let is_array = if let Some(array_type) = field_def.get("type") {
                                                if array_type == "array" {
                                                    true
                                                } else if let serde_json::Value::Array(types) = array_type {
                                                    // Handle nullable types like ["array", "null"]
                                                    types.iter().any(|t| t == "array")
                                                } else {
                                                    false
                                                }
                                            } else {
                                                false
                                            };
                                            
                                            // Debug output
                                            println!("Field: {}, Type: {:?}, Is array: {}", field_name, field_def.get("type"), is_array);

                                            if is_array {
                                                if let Some(items) = field_def.get("items") {
                                                    if let Some(desc) = items.get("description") {
                                                        if let Some(desc_str) = desc.as_str() {
                                                            if desc_str.starts_with("Record ID of table: ") {
                                                                let related_table = desc_str.replace("Record ID of table: ", "");
                                                                
                                                                // Check if this is a junction table (relation table)
                                                                // If so, we need to find the actual target table
                                                                let actual_target = if related_table.ends_with("_on") || related_table.contains("relation") {
                                                                    // This is likely a junction table, try to find the actual target
                                                                    // For now, we'll use a simple heuristic: if it's commented_on, target is comment
                                                                    if related_table == "commented_on" {
                                                                        "comment".to_string()
                                                                    } else {
                                                                        related_table.clone()
                                                                    }
                                                                } else {
                                                                    related_table.clone()
                                                                };
                                                                
                                                                // Debug output
                                                                println!("Field: {}, Original table: {}, Actual target: {}", field_name, related_table, actual_target);
                                                                
                                                                // This is a 1:many relationship (array)
                                                                table_rels.push((field_name.clone(), actual_target, "many".to_string()));
                                                            }
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Check if this is a single record field (1:1)
                                                if let Some(desc) = field_def.get("description") {
                                                    if let Some(desc_str) = desc.as_str() {
                                                        if desc_str.starts_with("Record ID of table: ") {
                                                            let related_table = desc_str.replace("Record ID of table: ", "");
                                                            // This is a 1:1 relationship (single value)
                                                            table_rels.push((field_name.clone(), related_table, "one".to_string()));
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        if !table_rels.is_empty() {
                                            all_rels.insert(table_name.clone(), table_rels);
                                        }
                                    }
                                }
                            }
                        }
                        Some(all_rels)
                    });

                // Now update the interface definitions to use proper relationship types
                let updated_content = if let Some(ref table_rels) = table_relationships {
                    self.update_interface_relationships(content, table_rels)?
                } else {
                    content.to_string()
                };

                // Generate the interface lines
                let mut interface_lines = vec![
                    "/**".to_string(),
                    " * Relationship definition for a single relationship field".to_string(),
                    " */".to_string(),
                    "export interface RelationshipDefinition<Model = any> {".to_string(),
                    "    /** The related model type */".to_string(),
                    "    model: Model;".to_string(),
                    "    /** The related table name */".to_string(),
                    "    table: string;".to_string(),
                    "    /** Whether this is a 1:1 or 1:many relationship */".to_string(),
                    "    cardinality: \"one\" | \"many\";".to_string(),
                    "}".to_string(),
                    "".to_string(),
                    "/**".to_string(),
                    " * Relationships between tables - nested object structure".to_string(),
                    " * Maps each table to its relationship fields with their definitions".to_string(),
                    " */".to_string(),
                    "export interface Relationships {".to_string(),
                ];

                // Generate nested interface structure
                if let Some(ref table_rels) = table_relationships {
                    for (table_name, rels) in table_rels {
                        if rels.is_empty() {
                            interface_lines.push(format!("    {}: {{}};", table_name));
                        } else {
                            interface_lines.push(format!("    {}: {{", table_name));
                            for (field_name, related_table, cardinality) in rels {
                                interface_lines.push(format!("        {}: {{", field_name));
                                interface_lines.push(format!("            model: Schema[\"{}\"];", related_table));
                                interface_lines.push(format!("            table: \"{}\";", related_table));
                                interface_lines.push(format!("            cardinality: \"{}\";", cardinality));
                                interface_lines.push("        };".to_string());
                            }
                            interface_lines.push("    };".to_string());
                        }
                    }
                } else {
                    for (table_name, _rel_data) in rel_map {
                        interface_lines.push(format!("    {}: {{}};", table_name));
                    }
                }

                interface_lines.push("}".to_string());
                interface_lines.push("".to_string());

                // RELATIONSHIPS constant removed - relationships are type-only now
                // The Relationships interface above provides type safety without runtime overhead

                // RELATION_TABLES constant also removed - not needed for runtime

                return Ok(format!("{}\n\n{}\n", updated_content, interface_lines.join("\n")));
            }
        }

        // No relationships found, return original content
        Ok(content.to_string())
    }

    fn update_interface_relationships(&self, content: &str, table_relationships: &std::collections::HashMap<String, Vec<(String, String, String)>>) -> Result<String> {
        let lines: Vec<&str> = content.lines().collect();
        let mut result = Vec::new();
        let mut i = 0;

        while i < lines.len() {
            let line = lines[i];
            
            // Check if this line starts an interface definition
            if line.trim_start().starts_with("export interface ") {
                let interface_name = line
                    .split_whitespace()
                    .nth(2)
                    .unwrap_or("")
                    .trim_end_matches(" {");
                
                // Check if this interface has relationships we need to update
                if let Some(relationships) = table_relationships.get(interface_name) {
                    result.push(line.to_string());
                    
                    // Find the opening brace
                    let mut brace_found = false;
                    let mut j = i;
                    
                    while j < lines.len() && !brace_found {
                        if lines[j].contains("{") {
                            brace_found = true;
                            
                            // If opening brace is not on the same line, add those lines too
                            if j > i {
                                for k in (i + 1)..=j {
                                    result.push(lines[k].to_string());
                                }
                                i = j;
                            }
                        }
                        j += 1;
                    }
                    
                    // Now find the closing brace and update relationship fields
                    if brace_found {
                        let mut brace_count = 0;
                        let mut started = false;
                        let mut closing_line_idx = i;
                        
                        for k in i..lines.len() {
                            for ch in lines[k].chars() {
                                if ch == '{' {
                                    brace_count += 1;
                                    started = true;
                                } else if ch == '}' {
                                    brace_count -= 1;
                                    if started && brace_count == 0 {
                                        closing_line_idx = k;
                                        break;
                                    }
                                }
                            }
                            if started && brace_count == 0 {
                                break;
                            }
                        }
                        
                        // Process lines within the interface
                        for k in (i + 1)..closing_line_idx {
                            let current_line = lines[k];
                            let mut updated_line = current_line.to_string();
                            
                            // Check if this line contains a relationship field
                            for (field_name, related_table, cardinality) in relationships {
                                if current_line.contains(field_name) {
                                    // Update the field type based on cardinality
                                    if cardinality == "many" {
                                        // For many relationships, use array of related type
                                        if current_line.contains("string[]") {
                                            updated_line = current_line.replace("string[]", &format!("Schema[\"{}\"][]", related_table));
                                        } else if current_line.contains("string") {
                                            updated_line = current_line.replace("string", &format!("Schema[\"{}\"][]", related_table));
                                        }
                                        
                                        // Handle nullable arrays
                                        if current_line.contains("| null") {
                                            updated_line = updated_line.replace(
                                                &format!("Schema[\"{}\"][]", related_table),
                                                &format!("Schema[\"{}\"][] | null", related_table)
                                            );
                                        }
                                    } else {
                                        // For one relationships, use single related type
                                        if current_line.contains("string") {
                                            updated_line = current_line.replace("string", &format!("Schema[\"{}\"]", related_table));
                                        }
                                        
                                        // Handle nullable single values
                                        if current_line.contains("| null") {
                                            updated_line = updated_line.replace(
                                                &format!("Schema[\"{}\"]", related_table),
                                                &format!("Schema[\"{}\"] | null", related_table)
                                            );
                                        }
                                    }
                                }
                            }
                            
                            result.push(updated_line);
                        }
                        
                        // Add the closing brace
                        result.push(lines[closing_line_idx].to_string());
                        i = closing_line_idx;
                    }
                } else {
                    // No relationships for this interface, add as-is
                    result.push(line.to_string());
                }
            } else {
                result.push(line.to_string());
            }
            
            i += 1;
        }
        
        Ok(result.join("\n"))
    }

    fn add_schema_constant(&self, content: String, schema: &str) -> Result<String> {
        match self.format {
            OutputFormat::Typescript => {
                // Escape the schema content for TypeScript template literal
                let escaped_schema = schema.replace("\\", "\\\\").replace("`", "\\`");

                Ok(format!(
                    "{}\n\n/**\n * The complete SurrealDB schema definition.\n * This constant contains the raw .surql schema file content.\n */\nexport const SURQL_SCHEMA = `{}`;\n",
                    content, escaped_schema
                ))
            }
            OutputFormat::Dart => {
                // Escape the schema content for Dart string literal
                let escaped_schema = schema
                    .replace("\\", "\\\\")
                    .replace("\"", "\\\"")
                    .replace("$", "\\$");

                Ok(format!(
                    "{}\n\n/// The complete SurrealDB schema definition.\n/// This constant contains the raw .surql schema file content.\nconst String SURQL_SCHEMA = \"{}\";\n",
                    content, escaped_schema
                ))
            }
            OutputFormat::JsonSchema => {
                // For JSON, we don't add a schema constant
                Ok(content)
            }
        }
    }
}
