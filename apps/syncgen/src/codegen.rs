use anyhow::{Context, Result};
use std::fs;
use std::process::Command;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum OutputFormat {
    JsonSchema,
    Typescript,
    Dart,
}

impl OutputFormat {
    pub fn from_extension(path: &str) -> Option<Self> {
        if path.ends_with(".json") {
            Some(Self::JsonSchema)
        } else if path.ends_with(".ts") {
            Some(Self::Typescript)
        } else if path.ends_with(".dart") {
            Some(Self::Dart)
        } else {
            None
        }
    }
}

pub struct CodeGenerator {
    format: OutputFormat,
    include_header: bool,
}

impl CodeGenerator {
    pub fn new_with_header(format: OutputFormat, include_header: bool) -> Self {
        Self {
            format,
            include_header,
        }
    }

    pub fn generate(&self, json_schema_content: &str, _top_level_name: &str) -> Result<String> {
        let mut content = match self.format {
            OutputFormat::JsonSchema => json_schema_content.to_string(),
            OutputFormat::Typescript => self.generate_typescript(json_schema_content)?,
            OutputFormat::Dart => self.generate_dart(json_schema_content)?,
        };

        if self.include_header {
            let header = self.generate_header();
            content = format!("{}\n{}", header, content);
        }

        Ok(content)
    }

    fn generate_typescript(&self, json_schema_content: &str) -> Result<String> {
        self.run_quicktype(json_schema_content, "typescript")
    }

    fn generate_dart(&self, json_schema_content: &str) -> Result<String> {
        self.run_quicktype(json_schema_content, "dart")
    }

    fn generate_header(&self) -> String {
        match self.format {
            OutputFormat::Typescript => {
                format!(
                    "// ⚠️  WARNING: This file is automatically generated by syncgen.\n\
                     // Do not modify this file manually as changes will be overwritten.\n\
                     // To regenerate this file, run the syncgen command from the database package.\n\
                     // Generated on: {}\n",
                    chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC")
                )
            }
            OutputFormat::Dart => {
                format!(
                    "// ⚠️  WARNING: This file is automatically generated by syncgen.\n\
                     // Do not modify this file manually as changes will be overwritten.\n\
                     // To regenerate this file, run the syncgen command from the database package.\n\
                     // Generated on: {}\n",
                    chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC")
                )
            }
            OutputFormat::JsonSchema => {
                // For JSON, we'll add a comment in the schema itself
                String::new()
            }
        }
    }

    fn run_quicktype(&self, json_schema_content: &str, lang: &str) -> Result<String> {
        // Create a temporary file for the JSON schema
        let temp_dir = std::env::temp_dir();
        let schema_path = temp_dir.join("temp_schema.json");

        fs::write(&schema_path, json_schema_content)
            .context("Failed to write temporary schema file")?;

        // Build arguments based on language
        let mut args = vec!["-y", "quicktype", "--src-lang", "schema", "--lang", lang];

        // Add --just-types for TypeScript to exclude runtime validation code
        if lang == "typescript" {
            args.push("--just-types");
        }

        args.push(schema_path.to_str().unwrap());

        // Run quicktype
        let output = Command::new("npx")
            .args(&args)
            .output()
            .context("Failed to execute quicktype. Make sure npx is installed.")?;

        // Clean up temp file
        let _ = fs::remove_file(&schema_path);

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            anyhow::bail!("quicktype failed: {}", stderr);
        }

        let code =
            String::from_utf8(output.stdout).context("quicktype output is not valid UTF-8")?;

        Ok(code)
    }
}
