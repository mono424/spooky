use anyhow::{Context, Result};
use std::fs;
use std::process::Command;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum OutputFormat {
    JsonSchema,
    Typescript,
    Dart,
}

impl OutputFormat {
    pub fn from_extension(path: &str) -> Option<Self> {
        if path.ends_with(".json") {
            Some(Self::JsonSchema)
        } else if path.ends_with(".ts") {
            Some(Self::Typescript)
        } else if path.ends_with(".dart") {
            Some(Self::Dart)
        } else {
            None
        }
    }
}

pub struct CodeGenerator {
    format: OutputFormat,
    include_header: bool,
}

impl CodeGenerator {
    pub fn new_with_header(format: OutputFormat, include_header: bool) -> Self {
        Self {
            format,
            include_header,
        }
    }

    pub fn generate(&self, json_schema_content: &str, _top_level_name: &str) -> Result<String> {
        self.generate_with_schema(json_schema_content, _top_level_name, None)
    }

    pub fn generate_with_schema(
        &self,
        json_schema_content: &str,
        _top_level_name: &str,
        raw_schema: Option<&str>,
    ) -> Result<String> {
        let mut content = match self.format {
            OutputFormat::JsonSchema => json_schema_content.to_string(),
            OutputFormat::Typescript => self.generate_typescript(json_schema_content)?,
            OutputFormat::Dart => self.generate_dart(json_schema_content)?,
        };

        if self.include_header {
            let header = self.generate_header();
            content = format!("{}\n{}", header, content);
        }

        // Add raw schema constant for TypeScript and Dart
        if let Some(schema) = raw_schema {
            content = self.add_schema_constant(content, schema)?;
        }

        Ok(content)
    }

    fn generate_typescript(&self, json_schema_content: &str) -> Result<String> {
        let output = self.run_quicktype(json_schema_content, "typescript")?;
        Ok(self.add_index_signature_to_interfaces(output))
    }

    fn generate_dart(&self, json_schema_content: &str) -> Result<String> {
        self.run_quicktype(json_schema_content, "dart")
    }

    fn generate_header(&self) -> String {
        match self.format {
            OutputFormat::Typescript => {
                format!(
                    "// ⚠️  WARNING: This file is automatically generated by syncgen.\n\
                     // Do not modify this file manually as changes will be overwritten.\n\
                     // To regenerate this file, run the syncgen command from the database package.\n\
                     // Generated on: {}\n",
                    chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC")
                )
            }
            OutputFormat::Dart => {
                format!(
                    "// ⚠️  WARNING: This file is automatically generated by syncgen.\n\
                     // Do not modify this file manually as changes will be overwritten.\n\
                     // To regenerate this file, run the syncgen command from the database package.\n\
                     // Generated on: {}\n",
                    chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC")
                )
            }
            OutputFormat::JsonSchema => {
                // For JSON, we'll add a comment in the schema itself
                String::new()
            }
        }
    }

    fn run_quicktype(&self, json_schema_content: &str, lang: &str) -> Result<String> {
        // Create a temporary file for the JSON schema
        let temp_dir = std::env::temp_dir();
        let schema_path = temp_dir.join("schema.json");

        fs::write(&schema_path, json_schema_content)
            .context("Failed to write temporary schema file")?;

        // Build arguments based on language
        let mut args = vec!["-y", "quicktype", "--src-lang", "schema", "--lang", lang];

        // Add --just-types for TypeScript to exclude runtime validation code
        if lang == "typescript" {
            args.push("--just-types");
        }

        args.push(schema_path.to_str().unwrap());

        // Run quicktype
        let output = Command::new("npx")
            .args(&args)
            .output()
            .context("Failed to execute quicktype. Make sure npx is installed.")?;

        // Clean up temp file
        let _ = fs::remove_file(&schema_path);

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            anyhow::bail!("quicktype failed: {}", stderr);
        }

        let code =
            String::from_utf8(output.stdout).context("quicktype output is not valid UTF-8")?;

        Ok(code)
    }

    fn add_index_signature_to_interfaces(&self, content: String) -> String {
        let lines: Vec<&str> = content.lines().collect();
        let mut result = Vec::new();
        let mut i = 0;

        while i < lines.len() {
            let line = lines[i];
            result.push(line.to_string());

            // Check if this line starts an interface definition
            if line.trim_start().starts_with("export interface ") {
                // Find the opening brace
                let mut brace_found = false;
                let mut j = i;

                while j < lines.len() && !brace_found {
                    if lines[j].contains("{") {
                        brace_found = true;

                        // If opening brace is not on the same line as we just added, add those lines too
                        if j > i {
                            for k in (i + 1)..=j {
                                result.push(lines[k].to_string());
                            }
                            i = j;
                        }
                    }
                    j += 1;
                }

                // Now find the closing brace and check if we need to add the index signature
                if brace_found {
                    let mut brace_count = 0;
                    let mut started = false;
                    let mut closing_line_idx = i;
                    let mut has_properties = false;
                    let mut has_index_signature = false;

                    for k in i..lines.len() {
                        for ch in lines[k].chars() {
                            if ch == '{' {
                                brace_count += 1;
                                started = true;
                            } else if ch == '}' {
                                brace_count -= 1;
                                if started && brace_count == 0 {
                                    closing_line_idx = k;
                                    break;
                                }
                            }
                        }
                        if started && brace_count == 0 {
                            break;
                        }

                        // Check if there are properties (lines with : that aren't index signatures)
                        let trimmed = lines[k].trim();
                        if trimmed.contains(':') {
                            if trimmed.starts_with('[') && trimmed.contains("string]") && trimmed.contains(": any") {
                                has_index_signature = true;
                            } else if !trimmed.starts_with("//") && !trimmed.starts_with("*") {
                                has_properties = true;
                            }
                        }
                    }

                    // Add all lines until the closing brace
                    for k in (i + 1)..closing_line_idx {
                        result.push(lines[k].to_string());
                    }

                    // Add index signature before the closing brace if there are properties and no existing index signature
                    if has_properties && !has_index_signature && closing_line_idx > i {
                        // Get the indentation from the closing brace line
                        let closing_line = lines[closing_line_idx];
                        let indent = closing_line.chars().take_while(|c| c.is_whitespace()).collect::<String>();
                        result.push(format!("{}    [property: string]: any;", indent));
                    }

                    // Add the closing brace
                    result.push(lines[closing_line_idx].to_string());
                    i = closing_line_idx;
                }
            }

            i += 1;
        }

        result.join("\n")
    }

    fn add_schema_constant(&self, content: String, schema: &str) -> Result<String> {
        match self.format {
            OutputFormat::Typescript => {
                // Escape the schema content for TypeScript template literal
                let escaped_schema = schema.replace("\\", "\\\\").replace("`", "\\`");

                Ok(format!(
                    "{}\n\n/**\n * The complete SurrealDB schema definition.\n * This constant contains the raw .surql schema file content.\n */\nexport const SURQL_SCHEMA = `{}`;\n",
                    content, escaped_schema
                ))
            }
            OutputFormat::Dart => {
                // Escape the schema content for Dart string literal
                let escaped_schema = schema
                    .replace("\\", "\\\\")
                    .replace("\"", "\\\"")
                    .replace("$", "\\$");

                Ok(format!(
                    "{}\n\n/// The complete SurrealDB schema definition.\n/// This constant contains the raw .surql schema file content.\nconst String SURQL_SCHEMA = \"{}\";\n",
                    content, escaped_schema
                ))
            }
            OutputFormat::JsonSchema => {
                // For JSON, we don't add a schema constant
                Ok(content)
            }
        }
    }
}
