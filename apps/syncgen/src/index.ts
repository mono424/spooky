import { spawn } from "child_process";
import { fileURLToPath } from "url";
import { dirname, join } from "path";
import { readFileSync, writeFileSync, unlinkSync } from "fs";
import { tmpdir } from "os";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

export interface SyncgenOptions {
  input: string;
  output: string;
  format?: "json" | "typescript" | "dart" | "surql";
  pretty?: boolean;
  all?: boolean;
  noHeader?: boolean;
  append?: string;
}

export function runSyncgen(options: SyncgenOptions): Promise<string> {
  return new Promise((resolve, reject) => {
    const binaryPath = join(__dirname, "..", "target", "release", "syncgen");

    let inputPath = options.input;
    let tempFilePath: string | null = null;

    let finalContent = "";
    try {
      finalContent = readFileSync(options.input, "utf-8");
    } catch (err) {
      return reject(err);
    }

    if (options.append) {
      try {
        const appendContent = readFileSync(options.append, "utf-8");
        finalContent = finalContent + "\n\n" + appendContent;
      } catch (err) {
        return reject(err);
      }
    }

    // Check if output is .surql or format is surql
    const isSurqlOutput = options.output.endsWith(".surql") || options.format === "surql";

    if (isSurqlOutput) {
      try {
        const header = "-- This file is auto-generated. Do not edit manually.\n-- Generated by syncgen - any changes will be overwritten.\n\n";
        writeFileSync(options.output, header + finalContent, "utf-8");
        return resolve(`Successfully generated SQL at "${options.output}"`);
      } catch (err) {
        return reject(err);
      }
    }

    if (options.append) {
      try {
        const timestamp = Date.now();
        const rand = Math.floor(Math.random() * 10000);
        tempFilePath = join(tmpdir(), `syncgen-schema-${timestamp}-${rand}.surql`);
        
        writeFileSync(tempFilePath, finalContent, "utf-8");
        inputPath = tempFilePath;
      } catch (err) {
        return reject(err);
      }
    }

    const args = ["--input", inputPath, "--output", options.output];

    if (options.format) {
      args.push("--format", options.format);
    }

    if (options.pretty === true) {
      args.push("--pretty");
    }

    if (options.all === true) {
      args.push("--all");
    }

    if (options.noHeader === true) {
      args.push("--no-header");
    }

    const child = spawn(binaryPath, args);

    let stdout = "";
    let stderr = "";

    child.stdout.on("data", (data) => {
      stdout += data.toString();
    });

    child.stderr.on("data", (data) => {
      stderr += data.toString();
    });

    child.on("close", (code) => {
      if (tempFilePath) {
        try {
          unlinkSync(tempFilePath);
        } catch (e) {
          // Ignore error on cleanup
        }
      }

      if (code === 0) {
        resolve(stdout);
      } else {
        reject(new Error(`syncgen exited with code ${code}: ${stderr}`));
      }
    });

    child.on("error", (error) => {
      if (tempFilePath) {
        try {
          unlinkSync(tempFilePath);
        } catch (e) {
          // Ignore error on cleanup
        }
      }
      reject(error);
    });
  });
}
