// Simple generator: parse `models.dart` and emit helper map factory functions.
import 'dart:io';

final inputPath = 'lib/schema/models.dart';
final outputPath = 'lib/schema/models_maps.g.dart';

void main(List<String> args) {
  final input = File(inputPath);
  if (!input.existsSync()) {
    stderr.writeln('Error: $inputPath not found. Run from package root.');
    exit(2);
  }

  final content = input.readAsStringSync();

  final classes = _parseClasses(content);
  final generated = _render(classes);
  File(outputPath).writeAsStringSync(generated);
  stdout.writeln('Wrote $outputPath');
}

class ClassInfo {
  String name;
  // fieldName -> type (with ? if nullable)
  Map<String, String> fields;
  // jsonKey -> fieldName
  Map<String, String> jsonMap;

  ClassInfo(this.name, this.fields, this.jsonMap);
}

Map<String, ClassInfo> _parseClasses(String src) {
  final Map<String, ClassInfo> out = {};

  final classReg = RegExp(r'class\s+(\w+)\s*{');
  final matches = classReg.allMatches(src);
  for (final m in matches) {
    final name = m.group(1)!;
    // slice region from this class start to next class or end
    final start = m.end;
    final next = src.indexOf('\nclass ', start);
    final end = next == -1 ? src.length : next;
    final body = src.substring(start, end);

    final fields = <String, String>{};
    // Find field declarations like: String author; or DateTime? createdAt;
    final fieldReg = RegExp(r"(\w+[<>\w:]*(?:\?)?)\s+(\w+);", multiLine: true);
    for (final f in fieldReg.allMatches(body)) {
      final type = f.group(1)!.trim();
      final fname = f.group(2)!.trim();
      fields[fname] = type;
    }

    final jsonMap = <String, String>{};
    // find toJson body mapping lines: "key": field,
    final toJsonReg = RegExp(
      r'Map<String, dynamic> toJson\(\) => \{([\s\S]*?)\};',
      multiLine: true,
    );
    final toJsonMatch = toJsonReg.firstMatch(body);
    if (toJsonMatch != null) {
      final mapBody = toJsonMatch.group(1)!;
      final entryReg = RegExp(r'"([^"]+)"\s*:\s*([^,]+),');
      for (final e in entryReg.allMatches(mapBody)) {
        final key = e.group(1)!.trim();
        final value = e.group(2)!.trim();
        // value might be like 'createdAt?.toIso8601String()' or 'title'
        // extract bare field name at start
        final fieldNameMatch = RegExp(r'(\w+)').firstMatch(value);
        if (fieldNameMatch != null) {
          jsonMap[key] = fieldNameMatch.group(1)!;
        }
      }
    }

    out[name] = ClassInfo(name, fields, jsonMap);
  }

  return out;
}

String _render(Map<String, ClassInfo> classes) {
  final b = StringBuffer();
  b.writeln('// GENERATED FILE - do not edit.');
  b.writeln('// Generated by tool/gen_maps.dart');
  b.writeln();
  b.writeln("library schema.models_maps;\n");

  for (final c in classes.values) {
    // skip Schema root wrapper
    if (c.name == 'Schema') continue;
    final fnName = _uncap(c.name) + 'Map';
    b.writeln('/// Helper that builds a JSON-like map for `${c.name}`');
    b.write('Map<String, dynamic> $fnName({');
    // parameters
    final params = <String>[];
    for (final entry in c.fields.entries) {
      final fname = entry.key;
      final ftype = entry.value;
      // decide if required: if type doesn't end with ? and not List
      final isNullable = ftype.endsWith('?') || ftype.startsWith('List');
      final dartType = ftype.replaceAll('?', '').trim();
      final param = '${isNullable ? '' : 'required '}$ftype $fname';
      params.add(param);
    }
    b.write(params.join(', '));
    b.writeln('}) {');
    b.writeln('  return {');
    for (final entry in c.jsonMap.entries) {
      final jsonKey = entry.key;
      final field = entry.value;
      final ftype = c.fields[field] ?? 'dynamic';
      if (ftype.contains('DateTime')) {
        b.writeln("    '$jsonKey': $field?.toIso8601String(),");
      } else if (ftype.startsWith('List')) {
        b.writeln(
          "    '$jsonKey': $field == null ? [] : List<dynamic>.from($field.map((x) => x)),",
        );
      } else {
        b.writeln("    '$jsonKey': $field,");
      }
    }
    b.writeln('  };');
    b.writeln('}\n');
  }

  return b.toString();
}

String _uncap(String s) => s.isEmpty ? s : s[0].toLowerCase() + s.substring(1);
