-- This file is auto-generated. Do not edit manually.
-- Generated by syncgen - any changes will be overwritten.


-- ==================================================
-- SURREALISM MODULES
-- ==================================================

-- Define bucket for module files
DEFINE BUCKET modules BACKEND "file:/modules";

-- Define the XOR module
DEFINE MODULE mod::xor AS f"modules:/xor_module.surli";

-- ##################################################################
-- SCOPES & AUTHENTICATION
-- ##################################################################
DEFINE ACCESS account ON DATABASE TYPE RECORD
	SIGNUP {
		IF string::len($username) <= 3 { THROW "Username must be longer than 3 characters" };
		IF string::len($password) == 0 { THROW "Password cannot be empty" };

		LET $existing = (SELECT value id FROM user WHERE username = $username LIMIT 1)[0];
		IF $existing != NONE { THROW "Username '" + <string>$username + "' is already taken" };

		LET $u = CREATE user SET username = $username, password = crypto::argon2::generate($password);
		RETURN $u;
	}
	SIGNIN ( SELECT * FROM user WHERE username = $username AND crypto::argon2::compare(password, $password) )
	DURATION FOR TOKEN 365d, FOR SESSION 365d
;

-- ##################################################################
-- USER TABLE
-- ##################################################################

DEFINE TABLE user SCHEMAFULL
PERMISSIONS
  FOR update, delete WHERE $access = "account" AND id = $auth.id
  FOR create, select WHERE true;

DEFINE FIELD username ON TABLE user TYPE string
ASSERT $value != NONE AND string::len($value) > 3
PERMISSIONS
    FOR select WHERE true
    FOR create WHERE true
    FOR update WHERE $access = "account" AND id = $auth.id;
    
DEFINE INDEX unique_username ON TABLE user FIELDS username UNIQUE;

DEFINE FIELD password ON TABLE user TYPE string
ASSERT $value != NONE AND string::len($value) > 0
PERMISSIONS
    FOR select WHERE false
    FOR create WHERE true
    FOR update WHERE $access = "account" AND id = $auth.id;

DEFINE FIELD created_at ON TABLE user TYPE datetime
VALUE time::now()
PERMISSIONS
    FOR select WHERE false
    FOR create WHERE true
    FOR update WHERE $access = "account" AND id = $auth.id;

-- ##################################################################
-- THREAD TABLE
-- ##################################################################

DEFINE TABLE thread SCHEMAFULL
  PERMISSIONS
    FOR select WHERE true
    FOR update, delete, create WHERE $access = "account" AND author.id = $auth.id
;


DEFINE FIELD title ON TABLE thread TYPE string
    ASSERT $value != NONE AND string::len($value) > 0 AND string::len($value) <= 200;

DEFINE FIELD content ON TABLE thread TYPE string
    ASSERT $value != NONE AND string::len($value) > 0;

DEFINE FIELD author ON TABLE thread TYPE record<user>;

DEFINE FIELD created_at ON TABLE thread TYPE datetime
    VALUE time::now();

-- ##################################################################
-- COMMENT TABLE
-- ##################################################################

DEFINE TABLE comment SCHEMAFULL
  PERMISSIONS
    FOR select WHERE true
    FOR update, delete, create WHERE $access = "account" AND author.id = $auth.id
;

DEFINE FIELD thread ON TABLE comment TYPE record<thread>; -- @parent

DEFINE FIELD content ON TABLE comment TYPE string
    ASSERT $value != NONE AND string::len($value) > 0;

DEFINE FIELD author ON TABLE comment TYPE record<user>;

DEFINE FIELD created_at ON TABLE comment TYPE datetime
    VALUE time::now();

-- ##################################################################
-- RELATION TABLES
-- ##################################################################

DEFINE TABLE commented_on SCHEMAFULL TYPE RELATION
  FROM comment TO thread
  PERMISSIONS FOR select WHERE true;

DEFINE EVENT comment_created ON TABLE comment WHEN $event = "CREATE" THEN
  RELATE ($after.id)->commented_on->($after.thread)
;
-- ==================================================
-- 0. SPOOKY SCHEMA
-- The provisioned schema state for the database. Currently only used in local cache.
-- ==================================================

DEFINE TABLE IF NOT EXISTS _spooky_schema SCHEMAFULL;
DEFINE FIELD IF NOT EXISTS id ON _spooky_schema TYPE string;
DEFINE FIELD IF NOT EXISTS hash ON _spooky_schema TYPE string;
DEFINE FIELD IF NOT EXISTS created_at ON _spooky_schema TYPE datetime VALUE time::now();
DEFINE INDEX IF NOT EXISTS unique_hash ON _spooky_schema FIELDS hash UNIQUE;

-- ==================================================
-- 1. SPOOKY DATA HASH
-- The "Shadow Graph" tracking the state of every record.
-- ==================================================

DEFINE TABLE _spooky_data_hash SCHEMAFULL
    PERMISSIONS FOR select, create, update WHERE true; -- In prod, you might restrict write access to server-side only

-- The actual record being tracked (e.g., comment:abc, thread:123)
DEFINE FIELD RecordId ON TABLE _spooky_data_hash TYPE record
    PERMISSIONS FOR select, create, update WHERE true;

-- H_intrinsic: BLAKE3 hash of the record's own scalar fields
DEFINE FIELD IntrinsicHash ON TABLE _spooky_data_hash TYPE string
    PERMISSIONS FOR select, create, update WHERE true;

-- H_composition: XOR sum of all dependent children's TotalHashes
DEFINE FIELD CompositionHash ON TABLE _spooky_data_hash TYPE string
    PERMISSIONS FOR select, create, update WHERE true;

-- H_total: Intrinsic XOR Composition
DEFINE FIELD TotalHash ON TABLE _spooky_data_hash TYPE option<string>
    PERMISSIONS FOR select, create, update WHERE true;

-- Fast lookup by the original record ID
DEFINE INDEX idx_record_id ON TABLE _spooky_data_hash COLUMNS RecordId UNIQUE;

-- ==================================================
-- 2. SPOOKY INCANTATION
-- The Registry of active Live Queries (Incantations).
-- ==================================================

DEFINE TABLE _spooky_incantation SCHEMAFULL
    PERMISSIONS FOR select, create, update WHERE true;

-- The unique hash ID of the query + params
DEFINE FIELD Id ON TABLE _spooky_incantation TYPE string
    PERMISSIONS FOR select, create, update WHERE true;

-- The raw query string (for re-hydration/debugging)
DEFINE FIELD SurrealQL ON TABLE _spooky_incantation TYPE string
    PERMISSIONS FOR select, create, update WHERE true;

-- The current XOR sum of all results in this query
DEFINE FIELD Hash ON TABLE _spooky_incantation TYPE bytes
    PERMISSIONS FOR select, create, update WHERE true;

-- For garbage collection (Heartbeat)
DEFINE FIELD LastActiveAt ON TABLE _spooky_incantation TYPE datetime DEFAULT time::now()
    PERMISSIONS FOR select, create, update WHERE true;

-- How long this Incantation stays alive without activity
DEFINE FIELD TTL ON TABLE _spooky_incantation TYPE duration
    PERMISSIONS FOR select, create, update WHERE true;

-- Cleanup Triggers
-- When an incantation dies, clean up its lookup and tail records
DEFINE EVENT _spooky_cascade_delete_lookup ON TABLE _spooky_incantation WHEN $event = "DELETE" THEN {
    DELETE _spooky_incantation_lookup WHERE IncantationId = $before.Id;
    DELETE _spooky_incantation_tail WHERE IncantationId = $before.Id;
};


-- ==================================================
-- 3. SPOOKY INCANTATION LOOKUP
-- The Reverse Index: Maps Tables -> Incantations
-- ==================================================

DEFINE TABLE _spooky_incantation_lookup SCHEMAFULL
    PERMISSIONS FOR select, create, update WHERE true;

-- Link to the parent Incantation
DEFINE FIELD IncantationId ON TABLE _spooky_incantation_lookup TYPE string
    PERMISSIONS FOR select, create, update WHERE true;

-- The primary table being queried (e.g., 'thread')
DEFINE FIELD Table ON TABLE _spooky_incantation_lookup TYPE string
    PERMISSIONS FOR select, create, update WHERE true;

-- Filter logic used to check if a dirty record matches this query
-- Stored as an object e.g., { clause: "importance >= 3", args: [...] }
DEFINE FIELD Where ON TABLE _spooky_incantation_lookup TYPE object
    PERMISSIONS FOR select, create, update WHERE true;

-- Sorting Metadata needed to maintain order
DEFINE FIELD SortFields ON TABLE _spooky_incantation_lookup TYPE array<string>
    PERMISSIONS FOR select, create, update WHERE true;
DEFINE FIELD SortDirections ON TABLE _spooky_incantation_lookup TYPE array<string>
    PERMISSIONS FOR select, create, update WHERE true; -- 'ASC', 'DESC'

-- Indexes for performance
DEFINE INDEX idx_incantation ON TABLE _spooky_incantation_lookup COLUMNS IncantationId;
DEFINE INDEX idx_table ON TABLE _spooky_incantation_lookup COLUMNS Table;


-- ==================================================
-- 4. SPOOKY INCANTATION TAIL
-- Cursor Management for Pagination/Limits
-- ==================================================

DEFINE TABLE _spooky_incantation_tail SCHEMAFULL
    PERMISSIONS FOR select, create, update WHERE true;

-- Link to the parent Incantation
DEFINE FIELD IncantationId ON TABLE _spooky_incantation_tail TYPE string
    PERMISSIONS FOR select, create, update WHERE true;

-- The sort values of the *last* item in the current result set
-- Used to determine if a new record falls inside or outside the LIMIT window.
DEFINE FIELD TailValues ON TABLE _spooky_incantation_tail TYPE array<any>
    PERMISSIONS FOR select, create, update WHERE true;

DEFINE INDEX idx_incantation ON TABLE _spooky_incantation_tail COLUMNS IncantationId UNIQUE;


-- ==================================================
-- 5. SPOOKY RELATIONSHIP
-- The Graph Schema: Defines 'Bubble Up' vs 'Cascade Down'
-- ==================================================

DEFINE TABLE _spooky_relationship SCHEMAFULL
    PERMISSIONS FOR select, create, update WHERE true;

DEFINE FIELD ParentTable ON TABLE _spooky_relationship TYPE string
    PERMISSIONS FOR select, create, update WHERE true;
DEFINE FIELD ChildTable ON TABLE _spooky_relationship TYPE string
    PERMISSIONS FOR select, create, update WHERE true;

-- The field on the Child that holds the Parent's ID
DEFINE FIELD ChildField ON TABLE _spooky_relationship TYPE string
    PERMISSIONS FOR select, create, update WHERE true;

-- The Logic Flow: 'COMPOSITION' (Bubble Up) or 'REFERENCE' (Cascade Down)
DEFINE FIELD Type ON TABLE _spooky_relationship TYPE string 
    ASSERT $value INSIDE ['COMPOSITION', 'REFERENCE']
    PERMISSIONS FOR select, create, update WHERE true;

-- Enforce unique definition per relationship path
DEFINE INDEX idx_rel_unique ON TABLE _spooky_relationship COLUMNS ParentTable, ChildTable, ChildField UNIQUE;

-- ==================================================
-- AUTO-GENERATED SPOOKY EVENTS
-- ==================================================

-- Meta Table: _spooky_data_hash Mutation
-- Automatically recalculates TotalHash when IntrinsicHash or CompositionHash changes
DEFINE EVENT OVERWRITE _spooky_data_hash_mutation ON TABLE _spooky_data_hash
WHEN $before != $after AND $event != "DELETE"
THEN {
    LET $new_total = mod::xor::blake3_xor($after.IntrinsicHash, $after.CompositionHash);
    IF $new_total != $after.TotalHash THEN {
        UPDATE _spooky_data_hash SET TotalHash = $new_total WHERE RecordId = $after.RecordId;
    } END;
};

-- Table: comment Mutation
DEFINE EVENT OVERWRITE _spooky_comment_mutation ON TABLE comment
WHEN $before != $after AND $event != "DELETE"
THEN {
    LET $new_intrinsic = crypto::blake3(<string>{
        author: $after.author,
        content: $after.content,
        thread: $after.thread
    });

    LET $record_id = $before.id OR $after.id;
    LET $old_hash_data = (SELECT * FROM ONLY _spooky_data_hash WHERE RecordId = $record_id);
    LET $old_total = IF $old_hash_data.RecordId != NONE THEN $old_hash_data.TotalHash ELSE $new_intrinsic END;
    LET $composition = IF $old_hash_data.RecordId != NONE THEN $old_hash_data.CompositionHash ELSE crypto::blake3("") END;

    UPSERT _spooky_data_hash CONTENT {
        RecordId: $after.id,
        IntrinsicHash: $new_intrinsic,
        CompositionHash: $composition,
        TotalHash: NONE -- Placeholder, will be recalculated by event
    };

    -- BUBBLE UP to Parent (thread)
    LET $old_total = IF $old_hash_data.RecordId != NONE THEN $old_hash_data.TotalHash ELSE $new_intrinsic END;
    LET $new_total_after = (SELECT TotalHash FROM ONLY _spooky_data_hash WHERE RecordId = $after.id).TotalHash;
    IF $before.thread = $after.thread THEN {
        LET $delta = mod::xor::blake3_xor($old_total, $new_total_after);
        UPDATE _spooky_data_hash SET
            CompositionHash = mod::xor::blake3_xor(CompositionHash, $delta)
        WHERE RecordId = $after.thread;
    } ELSE {
        UPDATE _spooky_data_hash SET
            CompositionHash = mod::xor::blake3_xor(CompositionHash, $old_total)
        WHERE RecordId = $before.thread AND RecordId != NONE;

        UPDATE _spooky_data_hash SET
            CompositionHash = mod::xor::blake3_xor(CompositionHash, $new_total_after)
        WHERE RecordId = $after.thread AND RecordId != NONE;
    } END;

};

-- Table: comment Deletion
DEFINE EVENT OVERWRITE _spooky_comment_delete ON TABLE comment
WHEN $event = "DELETE"
THEN {
    LET $old_hash_data = (SELECT * FROM ONLY _spooky_data_hash WHERE RecordId = $before.id);
    LET $old_total = $old_hash_data.TotalHash;

    -- BUBBLE UP Delete to Parent
    IF $old_total != NONE AND $before.thread != NONE THEN {
        UPDATE _spooky_data_hash SET
            CompositionHash = mod::xor::blake3_xor(CompositionHash, $old_total)
        WHERE RecordId = $before.thread;
    } END;

    DELETE _spooky_data_hash WHERE RecordId = $before.id;
};

-- Table: thread Mutation
DEFINE EVENT OVERWRITE _spooky_thread_mutation ON TABLE thread
WHEN $before != $after AND $event != "DELETE"
THEN {
    LET $new_intrinsic = crypto::blake3(<string>{
        author: $after.author,
        content: $after.content,
        title: $after.title
    });

    LET $record_id = $before.id OR $after.id;
    LET $old_hash_data = (SELECT * FROM ONLY _spooky_data_hash WHERE RecordId = $record_id);
    LET $old_total = IF $old_hash_data.RecordId != NONE THEN $old_hash_data.TotalHash ELSE $new_intrinsic END;
    LET $composition = IF $old_hash_data.RecordId != NONE THEN $old_hash_data.CompositionHash ELSE crypto::blake3("") END;

    UPSERT _spooky_data_hash CONTENT {
        RecordId: $after.id,
        IntrinsicHash: $new_intrinsic,
        CompositionHash: $composition,
        TotalHash: NONE -- Placeholder, will be recalculated by event
    };

};

-- Table: thread Deletion
DEFINE EVENT OVERWRITE _spooky_thread_delete ON TABLE thread
WHEN $event = "DELETE"
THEN {
    LET $old_hash_data = (SELECT * FROM ONLY _spooky_data_hash WHERE RecordId = $before.id);
    LET $old_total = $old_hash_data.TotalHash;

    DELETE _spooky_data_hash WHERE RecordId = $before.id;
};

-- Table: user Mutation
DEFINE EVENT OVERWRITE _spooky_user_mutation ON TABLE user
WHEN $before != $after AND $event != "DELETE"
THEN {
    LET $new_intrinsic = crypto::blake3(<string>{
        username: $after.username
    });

    LET $record_id = $before.id OR $after.id;
    LET $old_hash_data = (SELECT * FROM ONLY _spooky_data_hash WHERE RecordId = $record_id);
    LET $old_total = IF $old_hash_data.RecordId != NONE THEN $old_hash_data.TotalHash ELSE $new_intrinsic END;
    LET $composition = IF $old_hash_data.RecordId != NONE THEN $old_hash_data.CompositionHash ELSE crypto::blake3("") END;

    UPSERT _spooky_data_hash CONTENT {
        RecordId: $after.id,
        IntrinsicHash: $new_intrinsic,
        CompositionHash: $composition,
        TotalHash: NONE -- Placeholder, will be recalculated by event
    };

    -- ==================================================
    -- CASCADE DOWN (Strict Compliance)
    -- Logic: user Change -> Updates Dependent INTRINSIC Hash
    -- ==================================================
    IF $old_hash_data.RecordId != NONE AND $new_intrinsic != $old_hash_data.IntrinsicHash THEN {
        LET $intrinsic_delta = mod::xor::blake3_xor($new_intrinsic, $old_hash_data.IntrinsicHash);

        -- Update comment records that reference user
        UPDATE _spooky_data_hash SET
            IntrinsicHash = mod::xor::blake3_xor(IntrinsicHash, $intrinsic_delta)
        WHERE RecordId IN (SELECT value id FROM comment WHERE author = $after.id);

        -- Update thread records that reference user
        UPDATE _spooky_data_hash SET
            IntrinsicHash = mod::xor::blake3_xor(IntrinsicHash, $intrinsic_delta)
        WHERE RecordId IN (SELECT value id FROM thread WHERE author = $after.id);


        -- ==================================================
        -- MANUAL BUBBLE UP
        -- Because we updated _spooky_data_hash directly,
        -- the dependent table's event won't fire.
        -- We must manually propagate changes to parent records.
        -- ==================================================

        -- Bubble up from comment to its parent via thread
        LET $affected_parents_comment = (
            SELECT count() AS count, thread 
            FROM comment 
            WHERE author = $after.id 
            GROUP BY thread
        );

        FOR $item IN $affected_parents_comment {
            -- XOR Logic: If record appears N times, Delta^N = Delta (if N is odd) or 0 (if N is even)
            IF $item.count % 2 == 1 {
                UPDATE _spooky_data_hash SET
                    CompositionHash = mod::xor::blake3_xor(CompositionHash, $intrinsic_delta)
                WHERE RecordId = $item.thread;
            }
        };

    } END;

};

-- Table: user Deletion
DEFINE EVENT OVERWRITE _spooky_user_delete ON TABLE user
WHEN $event = "DELETE"
THEN {
    LET $old_hash_data = (SELECT * FROM ONLY _spooky_data_hash WHERE RecordId = $before.id);
    LET $old_total = $old_hash_data.TotalHash;

    DELETE _spooky_data_hash WHERE RecordId = $before.id;
};

