import { Surreal } from 'surrealdb';
import { GenericContainer, StartedTestContainer, Wait } from 'testcontainers';

let container: StartedTestContainer | null = null;
let currentPort: number | null = null;

export const TEST_DB_CONFIG = {
  namespace: 'test_ns',
  database: 'test_db',
  user: 'root',
  pass: 'root',
};

async function getContainer() {
    if (container) return container;
    
    console.log("Starting SurrealDB container...");
    const path = require('path');
    const modulesDir = path.resolve(__dirname, '../../tests/.spooky');
    
    try {
        container = await new GenericContainer("surrealdb/surrealdb:v3.0.0-alpha.17-dev")
        .withExposedPorts(8000)
        .withEnvironment({ 
            "SURREAL_BUCKET_FOLDER_ALLOWLIST": "/modules",
            "SURREAL_CAPS_ALLOW_EXPERIMENTAL": "surrealism,files"
        })
        .withBindMounts([
            { source: path.join(modulesDir, 'xor_module.surli'), target: "/modules/xor_module.surli" }
        ])
        .withUser("root") 
        .withCommand(["start", "--log", "trace", "--user", "root", "--pass", "root", "--allow-all", "--allow-experimental"]) 
        .withStartupTimeout(30000)
        .withLogConsumer((stream) => {
            stream.pipe(process.stdout);
        })
        // Switch to a simple wait strategy initially to debug startup
        .withWaitStrategy(Wait.forLogMessage("Started web server on 0.0.0.0:8000"))
        .start();
    } catch (e) {
        console.error("Container failed to start");
        throw e;
    }

    if (!container) throw new Error("Container failed to initialize");
    
    currentPort = container!.getMappedPort(8000);
    console.log(`SurrealDB started on port ${currentPort}`);
    
    return container;
}

export async function createTestDb() {
  await getContainer();
  const db = new Surreal();
  
  if (!currentPort) throw new Error("Container not started properly");
  
  await db.connect(`http://localhost:${currentPort}/rpc`);
  await db.signin({
    username: TEST_DB_CONFIG.user,
    password: TEST_DB_CONFIG.pass,
  });
  
  // Clean start for every test execution
  // Must select namespace first to perform operations
  await db.use({ namespace: TEST_DB_CONFIG.namespace, database: TEST_DB_CONFIG.database });
  
  // Then we can manage databases. Wait, REMOVE DATABASE requires being in a namespace?
  // Yes.
  try {
      await db.query(`REMOVE DATABASE ${TEST_DB_CONFIG.database};`);
  } catch (e) { /* ignore if not exists */ }
  
  await db.query(`DEFINE DATABASE ${TEST_DB_CONFIG.database};`);
  await db.use({ namespace: TEST_DB_CONFIG.namespace, database: TEST_DB_CONFIG.database });
  
  // Load generated schema from .spooky
  const fs = require('fs');
  const path = require('path');
  const schemaPath = path.resolve(__dirname, '../../tests/.spooky/schema.gen.surql');
  
  if (fs.existsSync(schemaPath)) {
      console.log("Loading schema from:", schemaPath);
      let schema = fs.readFileSync(schemaPath, 'utf8');
      
      // No more mocking! Using real WASM module from .spooky
      // Schema is generated by syncgen.
      // Default from syncgen is usually file:/modules
      schema = schema.replace('file:/modules', 'file:///modules');
      
      const q = await db.query(schema) as any;
      const results = (q && typeof q.collect === 'function') ? await q.collect() : q;
      // Check for errors in results
      if (Array.isArray(results)) {
        for (const res of results) {
            if (res && res.status === 'ERR') {
                console.error("Schema Load Error:", res);
                throw new Error("Schema Load Failed: " + JSON.stringify(res));
            }
        }
      } else {
        // Just log if interesting, but usually it's fine (e.g. empty array or successful execution of first statement)
        if (results && results.status === 'ERR') {
             console.error("Schema Load Error:", results);
             throw new Error("Schema Load Failed: " + JSON.stringify(results));
        }
      }
  } else {
      console.warn("Schema file not found at " + schemaPath + ". Tests might fail.");
  }
  
  return db;
}

export async function clearTestDb(db: Surreal) {
  // Dangerous but needed for clean tests
  await db.query(`REMOVE DATABASE ${TEST_DB_CONFIG.database};`);
  // Re-select?
  // await db.use({ namespace: TEST_DB_CONFIG.namespace, database: TEST_DB_CONFIG.database });
}

